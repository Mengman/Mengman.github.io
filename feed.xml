<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://mengman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mengman.github.io/" rel="alternate" type="text/html" /><updated>2024-07-13T19:46:59+08:00</updated><id>https://mengman.github.io/feed.xml</id><title type="html">Mengman的异想世界</title><subtitle>Program 4 Fun/n Program 4 Life</subtitle><entry><title type="html">【学习 cmake step3】 设置编译参数</title><link href="https://mengman.github.io/c++/cmake/2024/07/13/CMake-by-examples-Step3.html" rel="alternate" type="text/html" title="【学习 cmake step3】 设置编译参数" /><published>2024-07-13T00:00:00+08:00</published><updated>2024-07-13T00:00:00+08:00</updated><id>https://mengman.github.io/c++/cmake/2024/07/13/CMake-by-examples-Step3</id><content type="html" xml:base="https://mengman.github.io/c++/cmake/2024/07/13/CMake-by-examples-Step3.html"><![CDATA[<p>目标：使用更加现代的方法为 MathFunctions library 设置编译参数</p>

<p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Usage%20Requirements%20for%20a%20Library.html">Step 3: Adding Usage Requirements for a Library</a></p>

<h2 id="源码实现">源码实现</h2>

<p>Step3/CMakeLists.txt</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>Tutorial VERSION 1.0<span class="p">)</span>

<span class="c1">#TODO 4: 使用 library tutorial_compiler_flags 来替换原来的 c++ 标准声明</span>
<span class="c1"># 老方法</span>
<span class="c1"># set(CMAKE_CXX_STANDARD 11)</span>
<span class="c1"># set(CMAKE_CXX_STANDARD_REQUIRED True)</span>

<span class="nb">add_library</span><span class="p">(</span>tutorial_compiler_flags INTERFACE<span class="p">)</span>
<span class="nb">target_compile_features</span><span class="p">(</span>tutorial_compiler_flags INTERFACE cxx_std_11<span class="p">)</span>

<span class="nf">comfigure_file</span><span class="p">(</span>TutorialConfig.h.in TutorialConfig.h<span class="p">)</span>

<span class="c1">#TODO 2: 删除 EXTRA_INCLUDES list</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>MathFunctions<span class="p">)</span>
<span class="c1"># list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions")</span>

<span class="nb">add_executable</span><span class="p">(</span>Tutorial tutorial.cxx<span class="p">)</span>

<span class="c1">#TODO 5: 添加 tutorial_compiler_flags 到项目的 link 中</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>Tutorial PUBLIC
					  MathFunctions
					  tutorial_compiler_flags<span class="p">)</span>

<span class="c1">#TODO 3: 移除子项目的 include 路径</span>
<span class="nb">target_include_directories</span><span class="p">(</span>Tutorial PUBLIC
						  <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span><span class="s2">"</span>
						  <span class="c1">#${EXTRA_INCLUDES}</span>
					<span class="p">)</span>

</code></pre></div></div>

<p>Step3/MathFunctions/CMakeLists.txt</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>MathFunctions MathFunctions.cxx<span class="p">)</span>

<span class="c1">#TODO 1: 声明任何依赖 MathFunnctions 库的项目都需要 include 当前源代码目录</span>
<span class="nb">target_include_directories</span><span class="p">(</span>MathFunctions INTERFACE <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span><span class="p">)</span>

<span class="nb">option</span><span class="p">(</span>USE_MYMATH <span class="s2">"Use tutorial provided math implementation"</span> ON<span class="p">)</span>
<span class="nb">if</span> <span class="p">(</span>USE_MYMATH<span class="p">)</span>
  <span class="nb">target_compile_definitions</span><span class="p">(</span>MathFunctions PRIVATE <span class="s2">"USE_MYMATH"</span><span class="p">)</span>
  <span class="nb">add_library</span><span class="p">(</span>SqrtLibrary STATIC
              mysqrt.cxx
              <span class="p">)</span>
  
  <span class="c1"># TODO 6: Link SqrtLibrary to tutorial_compiler_flags</span>
  <span class="nb">target_link_libraries</span><span class="p">(</span>SqrtLibrary PUBLIC tutorial_compiler_flags<span class="p">)</span>
  <span class="nb">target_link_libraries</span><span class="p">(</span>MathFunctions PRIVATE SqrtLibrary<span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
  
<span class="c1"># TODO 7: Link MathFunctions to tutorial_compiler_flags</span>
<span class="nb">target_link_directories</span><span class="p">(</span>MathFunctions PUBLIC tutorial_compiler_flags<span class="p">)</span>
</code></pre></div></div>

<p>总结一下。第一，通过在 MathFunctions 库用 <code class="language-plaintext highlighter-rouge">target_include_directories</code> 命令声明了自己的 include 依赖，从而使得每个依赖 MathFunctions 库的项目都会自动 include 声明的路径；第二， 结合声明 <code class="language-plaintext highlighter-rouge">INTERFACE</code> 模式的 library <code class="language-plaintext highlighter-rouge">tutorial_compiler_flags</code> 并且设置它的编译功能 <code class="language-plaintext highlighter-rouge">target_compile_features</code> 来替换，原来基于 <code class="language-plaintext highlighter-rouge">set</code> 命令方式设置 C++ 标准，它的好处是子项目直接添加 <code class="language-plaintext highlighter-rouge">tutorial_compiler_flags</code> 依赖就好，避免重复设置 <code class="language-plaintext highlighter-rouge">CMAKE_CXX_STANDARD</code> 变量。</p>

<h2 id="interface-作用域">interface 作用域</h2>

<h3 id="target_include_directories">target_include_directories</h3>
<p>在 step1 中简单介绍过 interface 作用域的作用是 “添加的目录将作为接口包含目录,对于依赖于该目标的其他目标可见”。这里再深入介绍一下 <code class="language-plaintext highlighter-rouge">target_include_directories</code> 在 <code class="language-plaintext highlighter-rouge">INTERFACE</code> 作用域下的表现。</p>

<p>当 <code class="language-plaintext highlighter-rouge">target_include_directories</code> 命令将作用域设置为 <code class="language-plaintext highlighter-rouge">INTERFACE</code>形式,那么被添加的包含<strong>目录不会被该目标本身使用</strong>, 而是被传递给链接到该目标的其他依赖目标使用。</p>

<p>例如,如果有一个静态库 <code class="language-plaintext highlighter-rouge">mylib</code>依赖于第三方库 <code class="language-plaintext highlighter-rouge">thirdparty</code>,在编译<code class="language-plaintext highlighter-rouge">mylib</code>时需要包含<code class="language-plaintext highlighter-rouge">thirdparty</code>的头文件路径。我们可以这样写:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>mylib ....<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span>mylib INTERFACE /path/to/thirdparty/include<span class="p">)</span>
</code></pre></div></div>
<p>这样,当其他目标链接<code class="language-plaintext highlighter-rouge">mylib</code>时,<code class="language-plaintext highlighter-rouge">/path/to/thirdparty/include</code>这个包含目录也会被自动传递给它们使用。
总之,<code class="language-plaintext highlighter-rouge">target_include_directories</code>的<code class="language-plaintext highlighter-rouge">INTERFACE</code>作用域为处理包含目录依赖传递、模块化构建等提供了支持,值得在 CMakeLists.txt 中合理使用。</p>
<h3 id="add_library">add_library</h3>
<p>在CMake中，当使用<code class="language-plaintext highlighter-rouge">add_library</code>命令时，如果将作用域设置为<code class="language-plaintext highlighter-rouge">INTERFACE</code>，则不会生成实际的库文件，而只是定义一个接口目标(Interface Target)。接口目标的作用是为依赖于它的其他目标提供使用信息,比如包含目录、链接库、编译定义等。
使用接口目标的主要目的有以下几点:</p>
<ol>
  <li><strong>模块化构建</strong>
接口目标为将某些构建设置(如编译选项、依赖项等)集中到一个地方提供了一种方式,实现了构建系统的模块化。其他目标只需链接接口目标,就能获得相应的构建设置。</li>
  <li><strong>依赖传递</strong>
通过<code class="language-plaintext highlighter-rouge">target_link_libraries</code>将接口目标链接到其他目标时,接口目标暴露的所有使用信息(包括从其他依赖目标继承的)都会传递给链接的目标。这样可以自动处理依赖的依赖。</li>
  <li><strong>跨平台支持</strong>
接口目标可以根据不同平台设置不同的构建选项,从而实现跨平台支持。其他目标只需链接接口目标,无需关心具体的平台细节。</li>
  <li><strong>可重用性</strong>
接口目标本身不生成实际文件,所以易于在不同项目之间重用。</li>
  <li><strong>依赖可见性</strong>
将依赖项集中在接口目标中,可以提高构建系统的可见性和可理解性。
一个典型的使用接口目标的例子是,为某个第三方库创建一个接口库,将该库所需的所有构建信息集中在接口目标中,然后项目中其他目标只需链接这个接口目标即可。</li>
</ol>

<h2 id="target_compile_features">target_compile_features</h2>
<p><code class="language-plaintext highlighter-rouge">target_compile_features</code> 命令, 用于为目标(可执行程序或库)指定需要启用的编译器特性。帮助 target 利用编译器提供的最新语言和硬件特性,以编写更高效、更现代的代码。</p>

<p>以下是<code class="language-plaintext highlighter-rouge">target_compile_features</code>命令的基本用法:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_compile_features</span><span class="p">(</span>&lt;target&gt;
  &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;feature&gt; ...
  [PRIVATE|PUBLIC|INTERFACE] &lt;feature&gt; ...
<span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;target&gt;</code>: 指定要启用编译器特性的目标,可以是可执行程序或库。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code>: 指定编译器特性的作用范围。
    <ul>
      <li><code class="language-plaintext highlighter-rouge">PRIVATE</code>: 仅应用于目标本身。</li>
      <li><code class="language-plaintext highlighter-rouge">PUBLIC</code>: 应用于目标本身和依赖于该目标的其他目标。</li>
      <li><code class="language-plaintext highlighter-rouge">INTERFACE</code>: 仅应用于依赖于该目标的其他目标。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;feature&gt;</code>: 指定要启用的编译器特性,例如<code class="language-plaintext highlighter-rouge">cxx_std_11</code>用于启用C++11标准。</li>
</ul>

<p>示例:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>myapp main.cpp<span class="p">)</span>

<span class="c1"># 为 myapp 启用 C++11 标准</span>
<span class="nb">target_compile_features</span><span class="p">(</span>myapp PUBLIC cxx_std_11<span class="p">)</span>

<span class="c1"># 为 myapp 启用 C++14 标准和 OpenMP</span>
<span class="nb">target_compile_features</span><span class="p">(</span>myapp PRIVATE cxx_std_14 openmp<span class="p">)</span>
</code></pre></div></div>
<p>在上面的示例中,对于<code class="language-plaintext highlighter-rouge">myapp</code>目标,我们启用了C++11标准(对于<code class="language-plaintext highlighter-rouge">myapp</code>本身和依赖于它的其他目标),并且还私有地启用了C++14标准和OpenMP特性(仅对<code class="language-plaintext highlighter-rouge">myapp</code>本身)。</p>

<p>一些常见的<code class="language-plaintext highlighter-rouge">target_compile_features</code>可设置的特性:</p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>特性关键字</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C++标准特性</td>
      <td><code class="language-plaintext highlighter-rouge">cxx_std_98</code>, <code class="language-plaintext highlighter-rouge">cxx_std_11</code>, <code class="language-plaintext highlighter-rouge">cxx_std_14</code>, <code class="language-plaintext highlighter-rouge">cxx_std_17</code>, <code class="language-plaintext highlighter-rouge">cxx_std_20</code>, <code class="language-plaintext highlighter-rouge">cxx_std_23</code></td>
      <td>启用对应版本的C++标准支持</td>
    </tr>
    <tr>
      <td>OpenMP特性</td>
      <td><code class="language-plaintext highlighter-rouge">openmp</code></td>
      <td>启用OpenMP并行编程支持</td>
    </tr>
    <tr>
      <td>CUDA特性</td>
      <td><code class="language-plaintext highlighter-rouge">cuda_stdpar</code>, <code class="language-plaintext highlighter-rouge">cuda_std_11</code>, <code class="language-plaintext highlighter-rouge">cuda_std_14</code>, <code class="language-plaintext highlighter-rouge">cuda_std_17</code></td>
      <td>启用对应版本的CUDA标准并行算法支持</td>
    </tr>
    <tr>
      <td>综合特性</td>
      <td><code class="language-plaintext highlighter-rouge">stdpar_latest</code>, <code class="language-plaintext highlighter-rouge">cuda_latest</code></td>
      <td>启用最新的标准并行算法支持(包括C++和CUDA)</td>
    </tr>
    <tr>
      <td>硬件特性</td>
      <td><code class="language-plaintext highlighter-rouge">sse</code>, <code class="language-plaintext highlighter-rouge">sse2</code>, <code class="language-plaintext highlighter-rouge">avx</code>, <code class="language-plaintext highlighter-rouge">avx2</code>, <code class="language-plaintext highlighter-rouge">fma</code></td>
      <td>启用对应的SIMD指令集支持</td>
    </tr>
    <tr>
      <td>警告选项</td>
      <td><code class="language-plaintext highlighter-rouge">warn_uninitialized</code>, <code class="language-plaintext highlighter-rouge">warn_nullptr</code></td>
      <td>启用相关警告选项</td>
    </tr>
    <tr>
      <td>调试特性</td>
      <td><code class="language-plaintext highlighter-rouge">address_sanitizer</code>, <code class="language-plaintext highlighter-rouge">thread_sanitizer</code>, <code class="language-plaintext highlighter-rouge">undefined_behavior_sanitizer</code></td>
      <td>启用相应的内存/线程/未定义行为检测器</td>
    </tr>
    <tr>
      <td>其他语言特性</td>
      <td><code class="language-plaintext highlighter-rouge">c_std_99</code>, <code class="language-plaintext highlighter-rouge">c_std_11</code>, <code class="language-plaintext highlighter-rouge">objc_std_11</code></td>
      <td>分别启用对应版本的C语言和Objective-C语言支持</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="C++" /><category term="cmake" /><summary type="html"><![CDATA[目标：使用更加现代的方法为 MathFunctions library 设置编译参数 Step 3: Adding Usage Requirements for a Library 源码实现 Step3/CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(Tutorial VERSION 1.0) #TODO 4: 使用 library tutorial_compiler_flags 来替换原来的 c++ 标准声明 # 老方法 # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) add_library(tutorial_compiler_flags INTERFACE) target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11) comfigure_file(TutorialConfig.h.in TutorialConfig.h) #TODO 2: 删除 EXTRA_INCLUDES list add_subdirectory(MathFunctions) # list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions") add_executable(Tutorial tutorial.cxx) #TODO 5: 添加 tutorial_compiler_flags 到项目的 link 中 target_link_libraries(Tutorial PUBLIC MathFunctions tutorial_compiler_flags) #TODO 3: 移除子项目的 include 路径 target_include_directories(Tutorial PUBLIC "${PROJECT_BINARY_DIR}" #${EXTRA_INCLUDES} ) Step3/MathFunctions/CMakeLists.txt add_library(MathFunctions MathFunctions.cxx) #TODO 1: 声明任何依赖 MathFunnctions 库的项目都需要 include 当前源代码目录 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}) option(USE_MYMATH "Use tutorial provided math implementation" ON) if (USE_MYMATH) target_compile_definitions(MathFunctions PRIVATE "USE_MYMATH") add_library(SqrtLibrary STATIC mysqrt.cxx ) # TODO 6: Link SqrtLibrary to tutorial_compiler_flags target_link_libraries(SqrtLibrary PUBLIC tutorial_compiler_flags) target_link_libraries(MathFunctions PRIVATE SqrtLibrary) endif() # TODO 7: Link MathFunctions to tutorial_compiler_flags target_link_directories(MathFunctions PUBLIC tutorial_compiler_flags) 总结一下。第一，通过在 MathFunctions 库用 target_include_directories 命令声明了自己的 include 依赖，从而使得每个依赖 MathFunctions 库的项目都会自动 include 声明的路径；第二， 结合声明 INTERFACE 模式的 library tutorial_compiler_flags 并且设置它的编译功能 target_compile_features 来替换，原来基于 set 命令方式设置 C++ 标准，它的好处是子项目直接添加 tutorial_compiler_flags 依赖就好，避免重复设置 CMAKE_CXX_STANDARD 变量。 interface 作用域 target_include_directories 在 step1 中简单介绍过 interface 作用域的作用是 “添加的目录将作为接口包含目录,对于依赖于该目标的其他目标可见”。这里再深入介绍一下 target_include_directories 在 INTERFACE 作用域下的表现。 当 target_include_directories 命令将作用域设置为 INTERFACE形式,那么被添加的包含目录不会被该目标本身使用, 而是被传递给链接到该目标的其他依赖目标使用。 例如,如果有一个静态库 mylib依赖于第三方库 thirdparty,在编译mylib时需要包含thirdparty的头文件路径。我们可以这样写: add_library(mylib ....) target_include_directories(mylib INTERFACE /path/to/thirdparty/include) 这样,当其他目标链接mylib时,/path/to/thirdparty/include这个包含目录也会被自动传递给它们使用。 总之,target_include_directories的INTERFACE作用域为处理包含目录依赖传递、模块化构建等提供了支持,值得在 CMakeLists.txt 中合理使用。 add_library 在CMake中，当使用add_library命令时，如果将作用域设置为INTERFACE，则不会生成实际的库文件，而只是定义一个接口目标(Interface Target)。接口目标的作用是为依赖于它的其他目标提供使用信息,比如包含目录、链接库、编译定义等。 使用接口目标的主要目的有以下几点: 模块化构建 接口目标为将某些构建设置(如编译选项、依赖项等)集中到一个地方提供了一种方式,实现了构建系统的模块化。其他目标只需链接接口目标,就能获得相应的构建设置。 依赖传递 通过target_link_libraries将接口目标链接到其他目标时,接口目标暴露的所有使用信息(包括从其他依赖目标继承的)都会传递给链接的目标。这样可以自动处理依赖的依赖。 跨平台支持 接口目标可以根据不同平台设置不同的构建选项,从而实现跨平台支持。其他目标只需链接接口目标,无需关心具体的平台细节。 可重用性 接口目标本身不生成实际文件,所以易于在不同项目之间重用。 依赖可见性 将依赖项集中在接口目标中,可以提高构建系统的可见性和可理解性。 一个典型的使用接口目标的例子是,为某个第三方库创建一个接口库,将该库所需的所有构建信息集中在接口目标中,然后项目中其他目标只需链接这个接口目标即可。 target_compile_features target_compile_features 命令, 用于为目标(可执行程序或库)指定需要启用的编译器特性。帮助 target 利用编译器提供的最新语言和硬件特性,以编写更高效、更现代的代码。 以下是target_compile_features命令的基本用法: target_compile_features(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;feature&gt; ... [PRIVATE|PUBLIC|INTERFACE] &lt;feature&gt; ... ) &lt;target&gt;: 指定要启用编译器特性的目标,可以是可执行程序或库。 &lt;PRIVATE|PUBLIC|INTERFACE&gt;: 指定编译器特性的作用范围。 PRIVATE: 仅应用于目标本身。 PUBLIC: 应用于目标本身和依赖于该目标的其他目标。 INTERFACE: 仅应用于依赖于该目标的其他目标。 &lt;feature&gt;: 指定要启用的编译器特性,例如cxx_std_11用于启用C++11标准。 示例: add_executable(myapp main.cpp) # 为 myapp 启用 C++11 标准 target_compile_features(myapp PUBLIC cxx_std_11) # 为 myapp 启用 C++14 标准和 OpenMP target_compile_features(myapp PRIVATE cxx_std_14 openmp) 在上面的示例中,对于myapp目标,我们启用了C++11标准(对于myapp本身和依赖于它的其他目标),并且还私有地启用了C++14标准和OpenMP特性(仅对myapp本身)。 一些常见的target_compile_features可设置的特性: 特性 特性关键字 描述 C++标准特性 cxx_std_98, cxx_std_11, cxx_std_14, cxx_std_17, cxx_std_20, cxx_std_23 启用对应版本的C++标准支持 OpenMP特性 openmp 启用OpenMP并行编程支持 CUDA特性 cuda_stdpar, cuda_std_11, cuda_std_14, cuda_std_17 启用对应版本的CUDA标准并行算法支持 综合特性 stdpar_latest, cuda_latest 启用最新的标准并行算法支持(包括C++和CUDA) 硬件特性 sse, sse2, avx, avx2, fma 启用对应的SIMD指令集支持 警告选项 warn_uninitialized, warn_nullptr 启用相关警告选项 调试特性 address_sanitizer, thread_sanitizer, undefined_behavior_sanitizer 启用相应的内存/线程/未定义行为检测器 其他语言特性 c_std_99, c_std_11, objc_std_11 分别启用对应版本的C语言和Objective-C语言支持]]></summary></entry><entry><title type="html">CUDA 代码编译流程</title><link href="https://mengman.github.io/machinelearning/deeplearning/softwareenginer/cuda/2024/01/04/CUDA-compiler.html" rel="alternate" type="text/html" title="CUDA 代码编译流程" /><published>2024-01-04T00:00:00+08:00</published><updated>2024-01-04T00:00:00+08:00</updated><id>https://mengman.github.io/machinelearning/deeplearning/softwareenginer/cuda/2024/01/04/CUDA-compiler</id><content type="html" xml:base="https://mengman.github.io/machinelearning/deeplearning/softwareenginer/cuda/2024/01/04/CUDA-compiler.html"><![CDATA[<h1 id="1-编译流程">1 编译流程</h1>

<p>随着 Nvidia 不断更新 GPU 硬件设计架构，每一代架构更迭都会引入新的功能，在同一代架构中不同的 GPU 型号在硬件配置上与性能上也会有一些细小的差异。</p>

<p>Nvidia 提供了一套代号来标识 GPU 的<strong>真实架构</strong>，它的格式是 <code class="language-plaintext highlighter-rouge">sm_xy</code>，<code class="language-plaintext highlighter-rouge">x</code> 代表 GPU 架构世代的编号，<code class="language-plaintext highlighter-rouge">y</code>代表 GPU 在这个架构世代中的版本号。为了方便对比 GPU 能力，如果 <code class="language-plaintext highlighter-rouge">x1y1 &lt;= x2y2</code> 那么<code class="language-plaintext highlighter-rouge">sm_x1y1</code>中所有非 ISA 相关的功能都包含在 <code class="language-plaintext highlighter-rouge">sm_x2y2</code> 中了。</p>

<p>然而这并不能保证新的 GPU 架构就能兼容老的 GPU 架构的二进制代码，比如在 Fermi 架构上编译的代码就无法在Kepler GPU 上运行，因为它们的指令集与指令编码都是不一样的。只用在相同的架构下才能保持二进制兼容。为了解决这个问题，CUDA 代码采用了两阶段编译过程。</p>

<p><strong>第一个阶段</strong></p>

<p>nvcc 编译器将 CUDA 代码编译成 PTX 代码，这是一种类似汇编的代码。它基于<strong>虚拟架构</strong>进行编译，虚拟架构是根据 GPU 能力、功能来定义的。</p>

<p><strong>第二个阶段</strong></p>

<p>nvcc 编译器是包含在 GPU 驱动中，编译器可以预先或者在运行的时候根据<strong>真实架构</strong>将 PTX 代码编译成实际的二进制代码。</p>

<p>第一个阶段的<strong>虚拟架构</strong>要兼容第二个阶段的<strong>真实架构</strong>，<strong>虚拟架构</strong>的版本越低就越能兼容更多的<strong>真实架构</strong>，当然CUDA 代码支持的功能也就越少。</p>

<p><img src="/assets/virtual-architectures.png" alt="Two-Staged Compilation with Virtual and Real Architectures" /></p>

<p>对于在 CPU 上运行的 host code 与 GPU 上运行的 device code，编译器会分开进行编译。</p>

<ol>
  <li>nvcc 会将 device code (kernel 函数) 编译成 PTX code 或者二进制格式 (cubin object) 。</li>
  <li>nvcc 会修改 host code 中调用 kernel 的部分，修改为 PTX code 或者 cubin object 中实际的代码。</li>
</ol>

<p><strong>架构代号列表</strong></p>

<table>
  <thead>
    <tr>
      <th>虚拟架构代号</th>
      <th>真实架构代号</th>
      <th>CUDA支持版本</th>
      <th>支持架构</th>
      <th>支持硬件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>compute_50</td>
      <td>sm_50</td>
      <td>CUDA 6~11</td>
      <td>Maxwell</td>
      <td>Tesla/Quadro M series</td>
    </tr>
    <tr>
      <td>compute_52</td>
      <td>sm_52</td>
      <td>CUDA 6~11</td>
      <td>Maxwell</td>
      <td>GTX-980, GTX Titan X</td>
    </tr>
    <tr>
      <td>compute_53</td>
      <td>sm_53</td>
      <td>CUDA 6~11</td>
      <td>Maxwell</td>
      <td>Tegra TX1, Jetson Nano</td>
    </tr>
    <tr>
      <td>compute_60</td>
      <td>sm_60</td>
      <td>CUDA 8</td>
      <td>Pascal</td>
      <td>Tesla P100</td>
    </tr>
    <tr>
      <td>compute_61</td>
      <td>sm_61</td>
      <td>CUDA 8</td>
      <td>Pascal</td>
      <td>GTX 1080, GTX1070</td>
    </tr>
    <tr>
      <td>compute_62</td>
      <td>sm_62</td>
      <td>CUDA 8</td>
      <td>Pascal</td>
      <td>Jetson TX2</td>
    </tr>
    <tr>
      <td>compute_70</td>
      <td>sm_70</td>
      <td>CUDA 9</td>
      <td>Volta</td>
      <td>Tesla V100</td>
    </tr>
    <tr>
      <td>compute_72</td>
      <td>sm_72</td>
      <td>CUDA 9</td>
      <td>Volta</td>
      <td>Jetson AGX Xavier</td>
    </tr>
    <tr>
      <td>compute_75</td>
      <td>sm_75</td>
      <td>CUDA 10</td>
      <td>Turing</td>
      <td>RTX 2080, RTX 2070 Tesla T4</td>
    </tr>
    <tr>
      <td>compute_80</td>
      <td>sm_80</td>
      <td>CUDA 11.1</td>
      <td>Ampere</td>
      <td>A100</td>
    </tr>
    <tr>
      <td>compute_86</td>
      <td>sm_86</td>
      <td>CUDA 11.1</td>
      <td>Ampere</td>
      <td>RTX 3090</td>
    </tr>
    <tr>
      <td>compute_87</td>
      <td>sm_87</td>
      <td>CUDA 11.1</td>
      <td>Ampere</td>
      <td>Jetson AGX Orin</td>
    </tr>
    <tr>
      <td>compute_89</td>
      <td>sm_89</td>
      <td>CUDA 11.8</td>
      <td>Lovelace</td>
      <td>RTX 4090</td>
    </tr>
    <tr>
      <td>compute_90</td>
      <td>sm_90</td>
      <td>CUDA 12</td>
      <td>Hopper</td>
      <td>H100 H200</td>
    </tr>
    <tr>
      <td>compute_95</td>
      <td>sm_95</td>
      <td>CUDA 12</td>
      <td>Blackwell</td>
      <td>B100</td>
    </tr>
  </tbody>
</table>

<h1 id="2-ptx">2 PTX</h1>

<p>上一节提到的 <strong>PTX</strong> (Parallel Thread Execution) 是 Nvidia 为 CUDA 设计的一种低级虚拟机和指令架构，它是CUDA 代码的中间表示形式，有以下特征：</p>

<ol>
  <li>由虚拟指令集定义：用一套虚拟的并行指令集，用于表示 CUDA 设备功能。</li>
  <li>目标独立：采用抽象的寄存器和线程模型，不依赖于具体的 GPU 架构，可以针对不同的 GPU 生成优化机器代码。</li>
  <li>可移植： PTX 代码可以在不同的 CUDA 运行环境和 GPU设备上执行。</li>
  <li>JIT 编译： PTX 代码在执行前，有 GPU 驱动编译生成针对特定 GPU 的机器代码。</li>
  <li>可读性好：PTX 代码结构类似汇编，以文本形式保存，便于阅读和调试。</li>
  <li>虚拟寻址：提供了统一的虚拟寄存器和寻址空间</li>
</ol>

<h1 id="3-jit-编译">3 JIT 编译</h1>

<p>PTX 代码在目标机器上执行前，会由 GPU 驱动将 PTX 代码优化、编译为机器代码。PTX 代码的编译结果会被缓存下来，以免重复编译。但是如果更新了 GPU 驱动，那么 PTX 代码会重新编译。</p>

<p><strong>在不同操作系统下 JIT 缓存目录</strong></p>

<table>
  <thead>
    <tr>
      <th>操作系统</th>
      <th>缓存目录</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux</td>
      <td><code class="language-plaintext highlighter-rouge">~/.nv/ComputeCache</code></td>
    </tr>
    <tr>
      <td>Windows</td>
      <td><code class="language-plaintext highlighter-rouge">%APPDATA\%NVIDIA\ComputeCache</code></td>
    </tr>
    <tr>
      <td>MacOS</td>
      <td><code class="language-plaintext highlighter-rouge">$HOME/Library/Application Support/NVIDIA/ComputeCache</code></td>
    </tr>
  </tbody>
</table>

<p><strong>与 JIT 相关的环境变量配置</strong></p>

<table>
  <thead>
    <tr>
      <th>环境变量</th>
      <th>默认值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CUDA_CACHE_DISABLE</code></td>
      <td>0</td>
      <td>是否禁用 JIT cache，<code class="language-plaintext highlighter-rouge">1</code> 代表禁用 <code class="language-plaintext highlighter-rouge">0</code> 代表不禁用</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CUDA_CACHE_MAXSIZE</code></td>
      <td>256MB</td>
      <td>cache 的尺寸，最大值 4GB， 在 334 版本驱动前，默认值是 32MB</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CUDA_CACHE_PATH</code></td>
      <td>略</td>
      <td>设置 cache 目录</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CUDA_FORECE_PTX_JIT</code></td>
      <td>0</td>
      <td>设置为 <code class="language-plaintext highlighter-rouge">1</code> 时，强制忽略预编译好的机器代码，使用 JIT 从 PTX 代码中编译出机器代码</td>
    </tr>
  </tbody>
</table>

<h1 id="4-编译参数-arch--code">4 编译参数 arch &amp; code</h1>

<p><code class="language-plaintext highlighter-rouge">nvcc</code> 编译器在编译 CDUA 代码的时候提供了 <code class="language-plaintext highlighter-rouge">-gencode</code> 参数，这个参数接收 <code class="language-plaintext highlighter-rouge">arch=compute_xx</code> 与 <code class="language-plaintext highlighter-rouge">code=sm_xx</code> 作为参数。也可以单独使用 <code class="language-plaintext highlighter-rouge">-arch</code> 和 <code class="language-plaintext highlighter-rouge">-code</code> 来指定。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvcc x.cu <span class="nt">-gencode</span> <span class="nb">arch</span><span class="o">=</span>compute_50,code<span class="o">=</span>sm_50
</code></pre></div></div>

<h2 id="gpu-architecture-arch">–gpu-architecture(-arch)</h2>

<p>这个参数接受<strong>虚拟架构</strong>作为参数，通常来说这个参数与最终编译出来的 PTX 代码无关，它只是作为编译 CUDA 代码时候的预处理参数。</p>

<p>在 CUDA 编程中提供了宏 <code class="language-plaintext highlighter-rouge">__CUDA_ARCH__</code> 可以通过这个宏来控制编译的内容，当编译参数为 <code class="language-plaintext highlighter-rouge">-arch=compute_35</code> 时，<code class="language-plaintext highlighter-rouge">__CUDA__ARCH__</code> 的值就是 350。</p>

<h2 id="gpu-code-code">–gpu-code(-code)</h2>

<p>这个参数指定了 CUDA 代码实际要编译、优化的 PTX 代码对应的 Nvidia GPU。 其中虚拟架构代码 <code class="language-plaintext highlighter-rouge">compute_xx</code> 用来指定 PTX 代码版本，真实架构代码 <code class="language-plaintext highlighter-rouge">sm_xx</code> 用来指定机器代码。 如果程序在执行前无法找到设备 GPU 对应的二进制代码，那么就是使用 JIT 从 PTX 代码中编译出对应的机器代码。</p>

<p>同时使用 <code class="language-plaintext highlighter-rouge">-arch</code> 与 <code class="language-plaintext highlighter-rouge">-code</code> 参数时候，要确保使用的虚拟架构与真实架构兼容的。</p>

<p>当编译时只提供了 <code class="language-plaintext highlighter-rouge">-arch</code> 参数，这个时候其实是 <code class="language-plaintext highlighter-rouge">-arch</code> 与 <code class="language-plaintext highlighter-rouge">-code</code> 的简写，<code class="language-plaintext highlighter-rouge">-code</code> 的值默认等于前者。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 提供虚拟架构代码</span>
nvcc <span class="nt">-arch</span><span class="o">=</span>compute_61 
<span class="c"># 等价于</span>
nvcc <span class="nt">-arch</span><span class="o">=</span>compute_61 <span class="nt">-code</span><span class="o">=</span>compute_61

<span class="c"># 提供真实架构代码</span>
nvcc <span class="nt">-arch</span><span class="o">=</span>sm_61 
<span class="c"># 等价于</span>
nvcc <span class="nt">-arch</span><span class="o">=</span>compute_61 <span class="nt">-code</span><span class="o">=</span>sm_61,compute_61
</code></pre></div></div>

<h2 id="胖二进制fat-binaries">胖二进制(Fat Binaries)</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvcc x.cu 
	<span class="nt">-gencode</span> <span class="nb">arch</span><span class="o">=</span>compute_50,code<span class="o">=</span>sm_50
	<span class="nt">-gencode</span> <span class="nb">arch</span><span class="o">=</span>compute_60,code<span class="o">=</span>sm_60
	<span class="nt">-gencode</span> <span class="nb">arch</span><span class="o">=</span>compute_79,code<span class="o">=</span><span class="se">\'</span>compute_70,sm_70<span class="se">\'</span>
			
</code></pre></div></div>

<p>在编译的时候可以同时制定多套参数，编译出来的代码就可以支持多种不同架构的 GPU 设备，在具体执行的时候，驱动会选择当前真实架构对应的机器代码，如果找不到，那么就使用兼容的 PTX 代码 JIT 编译出对应的机器代码，这会导致在第一次执行时候速度会比较慢。</p>

<p>这种将同一份代码编译出多个不同架构代码的方式就叫”fat binaries”， 它带来的好处是让代码一次编译就能支持在多种设备上运行；它的缺点是，随着指定的架构版本越来越多，编译速度也越来越慢，编译出来的代码体积也越大。</p>]]></content><author><name></name></author><category term="machinelearning" /><category term="deeplearning" /><category term="softwareenginer" /><category term="CUDA" /><summary type="html"><![CDATA[1 编译流程 随着 Nvidia 不断更新 GPU 硬件设计架构，每一代架构更迭都会引入新的功能，在同一代架构中不同的 GPU 型号在硬件配置上与性能上也会有一些细小的差异。 Nvidia 提供了一套代号来标识 GPU 的真实架构，它的格式是 sm_xy，x 代表 GPU 架构世代的编号，y代表 GPU 在这个架构世代中的版本号。为了方便对比 GPU 能力，如果 x1y1 &lt;= x2y2 那么sm_x1y1中所有非 ISA 相关的功能都包含在 sm_x2y2 中了。 然而这并不能保证新的 GPU 架构就能兼容老的 GPU 架构的二进制代码，比如在 Fermi 架构上编译的代码就无法在Kepler GPU 上运行，因为它们的指令集与指令编码都是不一样的。只用在相同的架构下才能保持二进制兼容。为了解决这个问题，CUDA 代码采用了两阶段编译过程。 第一个阶段 nvcc 编译器将 CUDA 代码编译成 PTX 代码，这是一种类似汇编的代码。它基于虚拟架构进行编译，虚拟架构是根据 GPU 能力、功能来定义的。 第二个阶段 nvcc 编译器是包含在 GPU 驱动中，编译器可以预先或者在运行的时候根据真实架构将 PTX 代码编译成实际的二进制代码。 第一个阶段的虚拟架构要兼容第二个阶段的真实架构，虚拟架构的版本越低就越能兼容更多的真实架构，当然CUDA 代码支持的功能也就越少。 对于在 CPU 上运行的 host code 与 GPU 上运行的 device code，编译器会分开进行编译。 nvcc 会将 device code (kernel 函数) 编译成 PTX code 或者二进制格式 (cubin object) 。 nvcc 会修改 host code 中调用 kernel 的部分，修改为 PTX code 或者 cubin object 中实际的代码。 架构代号列表 虚拟架构代号 真实架构代号 CUDA支持版本 支持架构 支持硬件 compute_50 sm_50 CUDA 6~11 Maxwell Tesla/Quadro M series compute_52 sm_52 CUDA 6~11 Maxwell GTX-980, GTX Titan X compute_53 sm_53 CUDA 6~11 Maxwell Tegra TX1, Jetson Nano compute_60 sm_60 CUDA 8 Pascal Tesla P100 compute_61 sm_61 CUDA 8 Pascal GTX 1080, GTX1070 compute_62 sm_62 CUDA 8 Pascal Jetson TX2 compute_70 sm_70 CUDA 9 Volta Tesla V100 compute_72 sm_72 CUDA 9 Volta Jetson AGX Xavier compute_75 sm_75 CUDA 10 Turing RTX 2080, RTX 2070 Tesla T4 compute_80 sm_80 CUDA 11.1 Ampere A100 compute_86 sm_86 CUDA 11.1 Ampere RTX 3090 compute_87 sm_87 CUDA 11.1 Ampere Jetson AGX Orin compute_89 sm_89 CUDA 11.8 Lovelace RTX 4090 compute_90 sm_90 CUDA 12 Hopper H100 H200 compute_95 sm_95 CUDA 12 Blackwell B100 2 PTX 上一节提到的 PTX (Parallel Thread Execution) 是 Nvidia 为 CUDA 设计的一种低级虚拟机和指令架构，它是CUDA 代码的中间表示形式，有以下特征： 由虚拟指令集定义：用一套虚拟的并行指令集，用于表示 CUDA 设备功能。 目标独立：采用抽象的寄存器和线程模型，不依赖于具体的 GPU 架构，可以针对不同的 GPU 生成优化机器代码。 可移植： PTX 代码可以在不同的 CUDA 运行环境和 GPU设备上执行。 JIT 编译： PTX 代码在执行前，有 GPU 驱动编译生成针对特定 GPU 的机器代码。 可读性好：PTX 代码结构类似汇编，以文本形式保存，便于阅读和调试。 虚拟寻址：提供了统一的虚拟寄存器和寻址空间 3 JIT 编译 PTX 代码在目标机器上执行前，会由 GPU 驱动将 PTX 代码优化、编译为机器代码。PTX 代码的编译结果会被缓存下来，以免重复编译。但是如果更新了 GPU 驱动，那么 PTX 代码会重新编译。 在不同操作系统下 JIT 缓存目录 操作系统 缓存目录 Linux ~/.nv/ComputeCache Windows %APPDATA\%NVIDIA\ComputeCache MacOS $HOME/Library/Application Support/NVIDIA/ComputeCache 与 JIT 相关的环境变量配置 环境变量 默认值 说明 CUDA_CACHE_DISABLE 0 是否禁用 JIT cache，1 代表禁用 0 代表不禁用 CUDA_CACHE_MAXSIZE 256MB cache 的尺寸，最大值 4GB， 在 334 版本驱动前，默认值是 32MB CUDA_CACHE_PATH 略 设置 cache 目录 CUDA_FORECE_PTX_JIT 0 设置为 1 时，强制忽略预编译好的机器代码，使用 JIT 从 PTX 代码中编译出机器代码 4 编译参数 arch &amp; code nvcc 编译器在编译 CDUA 代码的时候提供了 -gencode 参数，这个参数接收 arch=compute_xx 与 code=sm_xx 作为参数。也可以单独使用 -arch 和 -code 来指定。 nvcc x.cu -gencode arch=compute_50,code=sm_50 –gpu-architecture(-arch) 这个参数接受虚拟架构作为参数，通常来说这个参数与最终编译出来的 PTX 代码无关，它只是作为编译 CUDA 代码时候的预处理参数。 在 CUDA 编程中提供了宏 __CUDA_ARCH__ 可以通过这个宏来控制编译的内容，当编译参数为 -arch=compute_35 时，__CUDA__ARCH__ 的值就是 350。 –gpu-code(-code) 这个参数指定了 CUDA 代码实际要编译、优化的 PTX 代码对应的 Nvidia GPU。 其中虚拟架构代码 compute_xx 用来指定 PTX 代码版本，真实架构代码 sm_xx 用来指定机器代码。 如果程序在执行前无法找到设备 GPU 对应的二进制代码，那么就是使用 JIT 从 PTX 代码中编译出对应的机器代码。 同时使用 -arch 与 -code 参数时候，要确保使用的虚拟架构与真实架构兼容的。 当编译时只提供了 -arch 参数，这个时候其实是 -arch 与 -code 的简写，-code 的值默认等于前者。 # 提供虚拟架构代码 nvcc -arch=compute_61 # 等价于 nvcc -arch=compute_61 -code=compute_61 # 提供真实架构代码 nvcc -arch=sm_61 # 等价于 nvcc -arch=compute_61 -code=sm_61,compute_61 胖二进制(Fat Binaries) nvcc x.cu -gencode arch=compute_50,code=sm_50 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_79,code=\'compute_70,sm_70\' 在编译的时候可以同时制定多套参数，编译出来的代码就可以支持多种不同架构的 GPU 设备，在具体执行的时候，驱动会选择当前真实架构对应的机器代码，如果找不到，那么就使用兼容的 PTX 代码 JIT 编译出对应的机器代码，这会导致在第一次执行时候速度会比较慢。 这种将同一份代码编译出多个不同架构代码的方式就叫”fat binaries”， 它带来的好处是让代码一次编译就能支持在多种设备上运行；它的缺点是，随着指定的架构版本越来越多，编译速度也越来越慢，编译出来的代码体积也越大。]]></summary></entry><entry><title type="html">【学习 cmake step1】 创建一个简单的 C++ 项目</title><link href="https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step1.html" rel="alternate" type="text/html" title="【学习 cmake step1】 创建一个简单的 C++ 项目" /><published>2024-01-04T00:00:00+08:00</published><updated>2024-01-04T00:00:00+08:00</updated><id>https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step1</id><content type="html" xml:base="https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step1.html"><![CDATA[<p>本文是我学习 <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">cmake 官方教程</a>的笔记，我在官方教程的基础上，对其中的知识点做了展开描述。</p>

<h1 id="什么是-cmake">什么是 cmake</h1>

<p>CMake 是一个跨平台的软件构建工具。</p>

<p>它的主要功能包括</p>
<ul>
  <li>跨平台：CMake 可以生成适用于 Windows、Linux、macOS 等多种平台的项目文件。</li>
  <li>灵活：CMake 的配置文件使用一种类似 C++ 的语言，可以灵活地描述软件的构建过程。</li>
  <li>可扩展：CMake 提供了丰富的 API，可以用于扩展其功能。</li>
</ul>

<p>CMake 支持构建多种编程语言项目，但是在 C/C++ ， CUDA 项目中使用的最广泛。</p>

<h2 id="cmake-与编译器的关系">cmake 与编译器的关系</h2>

<p>C/C++ 项目有很多中编译器如 Linux/Unix 上最常用的 GCC， Clang， Windows 上的 MSVC</p>

<h2 id="cmake-与-make-的对比">cmake 与 make 的对比</h2>

<p><code class="language-plaintext highlighter-rouge">CMake</code> 和 <code class="language-plaintext highlighter-rouge">make</code> 都是 C/C++ 项目常用的自动化编译工具，帮助实现项目依赖管理、源代码编译与依赖库链接。 <code class="language-plaintext highlighter-rouge">CMake</code>  通过编写 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> 文件来配置项目构建过程；<code class="language-plaintext highlighter-rouge">make</code> 通过编写 <code class="language-plaintext highlighter-rouge">Makefiles</code> 来配置项目构建过程。</p>

<p>它们之间又有明显的区别:</p>

<table>
  <thead>
    <tr>
      <th>特征</th>
      <th><code class="language-plaintext highlighter-rouge">CMake</code></th>
      <th><code class="language-plaintext highlighter-rouge">make</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>功能</td>
      <td>它是一个强大的元构建系统， 它根据项目配置来生成构建脚本(如 Makefiles)</td>
      <td>一个根据 Makefiles 来执行命令行指令的构建工具</td>
    </tr>
    <tr>
      <td>抽象程度</td>
      <td>高，可以编写与平台独立的 CMakeLists.txt 文件， cmake 会根据 CMakelists.txt 和具体平台、构建工具与编译器生成具体的编译脚本</td>
      <td>低，Makefiles 内容与特定平台、编译器绑定</td>
    </tr>
    <tr>
      <td>灵活性</td>
      <td>高，<code class="language-plaintext highlighter-rouge">CMake</code> 支持生成 <code class="language-plaintext highlighter-rouge">make</code> <code class="language-plaintext highlighter-rouge">ninja</code> 等构建项目的配置文件，并且支持通过配置变量来支持不同的操作系统和编译器</td>
      <td>低，对于跨平台、多编译支持较为困难</td>
    </tr>
    <tr>
      <td>复杂性</td>
      <td>高，<code class="language-plaintext highlighter-rouge">CMake</code> 的功能强大，学习曲线较高</td>
      <td>低，<code class="language-plaintext highlighter-rouge">Makefiles</code> 的语法简单</td>
    </tr>
    <tr>
      <td>输出</td>
      <td>生成构建脚本（如 Makefiles）</td>
      <td>编译完成的结果</td>
    </tr>
    <tr>
      <td>适合项目</td>
      <td>大型跨平台 C/C++、CUDA 项目</td>
      <td>小型项目、特定平台的项目，或者构建过程特别简单的项目（如 Golang 项目）</td>
    </tr>
  </tbody>
</table>

<h1 id="创建一个简单的-c-项目">创建一个简单的 C++ 项目</h1>

<h2 id="源码实现">源码实现</h2>

<p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/A%20Basic%20Starting%20Point.html">Step 1: A Basic Starting Point</a></p>

<p>构建一个简单的可执行项目
目标：</p>

<ol>
  <li>设置 cmake 版本要求</li>
  <li>设置项目名称</li>
  <li>设置项目可执行入口</li>
  <li>设置 C++ 语言版本</li>
  <li>生成一个配置头文件</li>
</ol>

<p>CMakeLists.txt</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 设置 cmake 版本要求</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>

<span class="c1"># 设置项目名称和版本</span>
<span class="nb">project</span><span class="p">(</span>Tutorial VERSION 1.0<span class="p">)</span>

<span class="c1"># 设置 C++ 版本为 11</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 11<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD_REQUIRED TRUE<span class="p">)</span>

<span class="nb">configure_file</span><span class="p">(</span>TutorialConfig.h.in TutorialConfig.h<span class="p">)</span>

<span class="c1"># 设置项目入口</span>
<span class="nb">add_executable</span><span class="p">(</span>Tutorial tutorial.cxx<span class="p">)</span>

<span class="nb">target_include_directories</span><span class="p">(</span>
	Tutorial PUBLIC
	<span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span><span class="s2">"</span>
<span class="p">)</span>
</code></pre></div></div>

<p>TutorialConfig.h.in</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
</span></code></pre></div></div>
<h2 id="命令讲解">命令讲解</h2>

<h3 id="cmake_minimum_required-命令">cmake_minimum_required 命令</h3>

<p><strong>cmake_minimum_required</strong> 是用来设置 cmake 版本要求的它的格式是
<code class="language-plaintext highlighter-rouge">cmake_minimum_required(VERSION &lt;min_version&gt; [FATAL_ERROR])</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;min_version&gt;</code>: 是支持的最小版本号， 如果要设置一个范围可以这么写 <code class="language-plaintext highlighter-rouge">3.10...3.27</code> 表示支持最老 3.10 到最新 3.27 版本的 cmake。</li>
  <li><code class="language-plaintext highlighter-rouge">FATAL_ERROR</code>是可选参数,如果指定了该参数,当检测到CMake的版本低于要求的最小版本时,CMake将终止并报错,而不是发出警告继续运行。</li>
</ul>

<h3 id="project-命令">project 命令</h3>
<p>它用来指定项目的名称、版本和支持的编程语言。</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">project</span><span class="p">(</span>ProjectName 
		VERSION MajorVersion.MinorVersion.PatchVersion 
		LANGUAGES languageName1 languageName2 ...<span class="p">)</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">project(projectName [LANGUAGES] [languageName1 languageName2 ...])</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">projectName</code> 是项目的名称,这是该命令的必需参数。</li>
  <li><code class="language-plaintext highlighter-rouge">VERSION</code> 是一个关键字, 用来指定项目的版本号</li>
  <li><code class="language-plaintext highlighter-rouge">MajorVersion.MinorVersion.PatchVersion </code> 带表项目的版本号</li>
  <li><code class="language-plaintext highlighter-rouge">LANGUAGES</code> 是一个关键字,用于指定项目支持的编程语言,这是可选参数。</li>
  <li><code class="language-plaintext highlighter-rouge">languageName1 languageName2 ...</code> 是一个或多个编程语言的名称,如<code class="language-plaintext highlighter-rouge">C</code>、<code class="language-plaintext highlighter-rouge">CXX</code>(C++)、<code class="language-plaintext highlighter-rouge">CUDA</code>等,这也是可选参数。</li>
</ul>

<p>使用该命令通常有以下几个目的:</p>
<ol>
  <li><strong>设置项目名称</strong>: 项目名称会用于生成各种文件和目标文件的名称前缀。</li>
  <li><strong>启用语言</strong>: 指定项目所使用的编程语言,CMake会自动包含适当的编译器和构建规则。如果没有指定,默认启用<code class="language-plaintext highlighter-rouge">C</code>和<code class="language-plaintext highlighter-rouge">CXX</code>语言。</li>
  <li><strong>设置编译器选项</strong>: CMake会根据指定的语言自动设置相应的编译器选项和预处理选项。</li>
  <li><strong>配置构建系统</strong>: 根据指定的语言,CMake会配置合适的构建系统,如Makefile或Visual Studio项目文件。</li>
</ol>

<h3 id="add_executable-命令">add_executable 命令</h3>
<p><code class="language-plaintext highlighter-rouge">add_executable</code> 命令是CMake中用于创建可执行目标的命令。它的基本语法如下:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>&lt;name&gt; [WIN32] [MACOSX_BUNDLE]
               [EXCLUDE_FROM_ALL]
               [source1] [source2 ...]<span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;name&gt;</code> 是必需的,用于指定生成的可执行文件的名称。</li>
  <li><code class="language-plaintext highlighter-rouge">[WIN32]</code> 是可选的,用于指示在Windows平台上生成一个Windows GUI程序。如果没有指定,默认会生成控制台程序。</li>
  <li><code class="language-plaintext highlighter-rouge">[MACOSX_BUNDLE]</code> 是可选的,用于在macOS平台上生成一个应用程序包(bundle)。</li>
  <li><code class="language-plaintext highlighter-rouge">[EXCLUDE_FROM_ALL]</code> 是可选的,用于指示该目标不应该被默认构建规则构建,需要手动构建。</li>
  <li><code class="language-plaintext highlighter-rouge">[source1] [source2 ...]</code> 是可选的,用于指定构建该可执行文件所需的源文件。如果没有列出源文件,那么CMake会查找与<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>同名的源文件。</li>
</ul>

<p>这个命令会将列出的源文件编译并链接成一个可执行文件。生成的可执行文件的名称和位置取决于本地构建工具的规则。</p>

<p>一些使用示例:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 创建一个简单的可执行文件</span>
<span class="nb">add_executable</span><span class="p">(</span>myapp main.cpp util.cpp<span class="p">)</span>

<span class="c1"># 在Windows上创建一个GUI程序</span>
<span class="nb">add_executable</span><span class="p">(</span>myapp WIN32 main.cpp gui.cpp<span class="p">)</span>

<span class="c1"># 在macOS上创建一个应用程序包</span>
<span class="nb">add_executable</span><span class="p">(</span>myapp MACOSX_BUNDLE main.cpp app.cpp<span class="p">)</span>

<span class="c1"># 将目标排除在默认构建之外</span>
<span class="nb">add_executable</span><span class="p">(</span>extraTool EXCLUDE_FROM_ALL tool.cpp<span class="p">)</span>
</code></pre></div></div>

<p>需要注意的是,<code class="language-plaintext highlighter-rouge">add_executable</code>通常与<code class="language-plaintext highlighter-rouge">target_link_libraries</code>命令一起使用,以链接所需的库文件。</p>

<p>总的来说,<code class="language-plaintext highlighter-rouge">add_executable</code>命令是创建可执行目标的关键命令,它允许你指定可执行文件的名称、目标平台以及构建所需的源文件。</p>

<h3 id="set--命令与--cmake_cxx_standardcmake_cxx_standard_required">set  命令与  CMAKE_CXX_STANDARD，CMAKE_CXX_STANDARD_REQUIRED</h3>
<p>set 命令是用来给 cmake 中变量赋值的。
基本语法如下:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="p">(</span>&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE]<span class="p">)</span>

<span class="c1"># 设置变量</span>
<span class="nb">set</span><span class="p">(</span>MY_VARIABLE <span class="s2">"Hello World"</span><span class="p">)</span>
<span class="c1"># 设置列表变量</span>
<span class="nb">set</span><span class="p">(</span>MY_LIST_VAR a b c d<span class="p">)</span>
<span class="c1"># 追加值到列表变量</span>
<span class="nb">set</span><span class="p">(</span>MY_LIST_VAR <span class="si">${</span><span class="nv">MY_LIST_VAR</span><span class="si">}</span> e f<span class="p">)</span>
<span class="c1"># 设置缓存变量</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -Wall"</span> CACHE STRING <span class="s2">"C++ compiler flags"</span> FORCE<span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;variable&gt;</code>是要设置的变量名。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;value&gt;...</code>是要赋给变量的值,可以是一个或多个值。如果有多个值,它们将被连接成一个字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">PARENT_SCOPE</code>是一个可选的参数,如果指定了它,那么该变量的值将被设置在父作用域中,而不是当前作用域。</li>
</ul>

<p><strong>CMAKE_CXX_STANDARD</strong> 是cmake 内置变量，用来指定 C++ 标准的版本。可以将其设置为以下值之一:</p>

<ul>
  <li>98 (C++98标准)</li>
  <li>11 (C++11标准)</li>
  <li>14 (C++14标准)</li>
  <li>17 (C++17标准)</li>
  <li>20 (C++20标准)</li>
  <li>23 (C++23标准,从CMake 3.20开始支持)</li>
</ul>

<p>如果没有显式设置该变量,CMake会根据编译器的默认行为来选择C++标准版本。</p>

<p><strong>CMAKE_CXX_STANDARD_REQUIRED</strong> 
这个变量是一个bool值,用于指定编译器是否必须支持由<code class="language-plaintext highlighter-rouge">CMAKE_CXX_STANDARD</code>指定的版本。如果设置为<code class="language-plaintext highlighter-rouge">ON</code>,那么如果编译器不支持该版本,CMake将终止配置阶段并报错。如果设置为<code class="language-plaintext highlighter-rouge">OFF</code>,CMake将尝试使用可用的最新C++标准版本,而不会报错。
默认情况下,<code class="language-plaintext highlighter-rouge">CMAKE_CXX_STANDARD_REQUIRED</code>为<code class="language-plaintext highlighter-rouge">OFF</code>。</p>

<h3 id="configure_file">configure_file</h3>
<p><code class="language-plaintext highlighter-rouge">configure_file</code> 是CMake中一个非常有用的命令,它允许你将一个输入文件转换为另一个输出文件,在转换过程中可以替换文件中的变量值。</p>

<p>该命令的基本语法如下:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">configure_file</span><span class="p">(</span>&lt;input&gt; &lt;output&gt;                
				[COPYONLY] [ESCAPE_QUOTES] [@ONLY]               
				[NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]<span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> 是要被配置的输入文件</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;output&gt;</code> 是转换后的输出文件</li>
  <li><code class="language-plaintext highlighter-rouge">COPYONLY</code> 是一个可选的标志,指示只复制文件而不替换其中的变量</li>
  <li><code class="language-plaintext highlighter-rouge">ESCAPE_QUOTES</code> 是一个可选的标志,指示是否对变量值中的引号进行转义</li>
  <li><code class="language-plaintext highlighter-rouge">@ONLY</code> 是一个可选的标志,指示只替换以<code class="language-plaintext highlighter-rouge">@VAR@</code>形式的变量值,忽略其他形式</li>
  <li><code class="language-plaintext highlighter-rouge">NEWLINE_STYLE</code> 是一个可选的参数,用于指定输出文件的换行符风格</li>
</ul>

<p>在输入文件中,可以使用<code class="language-plaintext highlighter-rouge">@VAR@</code>或<code class="language-plaintext highlighter-rouge">${VAR}</code>这样的语法来引用CMake变量。<code class="language-plaintext highlighter-rouge">configure_file</code>命令会在转换时将这些变量替换为其实际值。</p>

<p>这个命令的典型用途包括:</p>
<ol>
  <li><strong>生成配置头文件</strong>:通常会将一些编译时的选项、路径等信息写入头文件,供源代码使用。</li>
  <li><strong>生成配置文件</strong>:将一些运行时配置信息写入文本文件,供程序在运行时读取。</li>
  <li><strong>生成平台相关的文件</strong>:根据不同的目标平台生成不同的资源文件、脚本等。</li>
  <li><strong>打印模板文件</strong>:将模板文件中的变量替换后输出最终内容。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">configure_file</code>命令生成的输出文件的路径取决于输出文件路径的指定方式:</p>
<ol>
  <li><strong>使用相对路径指定输出文件</strong>
如果在<code class="language-plaintext highlighter-rouge">configure_file</code>命令中使用了相对路径来指定输出文件,那么生成的文件将位于相对于当前<code class="language-plaintext highlighter-rouge">CMAKE_BINARY_DIR</code>(构建目录)的路径下。</li>
</ol>

<p>例如:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">configure_file</span><span class="p">(</span>config.h.in config.h<span class="p">)</span>
</code></pre></div></div>
<p>这将在<code class="language-plaintext highlighter-rouge">CMAKE_BINARY_DIR</code>目录下生成<code class="language-plaintext highlighter-rouge">config.h</code>文件。</p>

<ol>
  <li><strong>使用绝对路径指定输出文件</strong>
如果使用绝对路径指定输出文件,生成的文件将位于该绝对路径所指定的位置,与<code class="language-plaintext highlighter-rouge">CMAKE_BINARY_DIR</code>无关。</li>
</ol>

<p>例如:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">configure_file</span><span class="p">(</span>config.h.in /usr/local/include/myproj/config.h<span class="p">)</span>
</code></pre></div></div>
<p>这将在<code class="language-plaintext highlighter-rouge">/usr/local/include/myproj/</code>目录下生成<code class="language-plaintext highlighter-rouge">config.h</code>文件。</p>

<ol>
  <li><strong>在BINARY_DIR子目录下生成文件</strong>
CMake还提供了一些变量,如<code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_BINARY_DIR</code>来指定输出文件路径。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">configure_file</span><span class="p">(</span>config.h.in <span class="si">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="si">}</span>/include/config.h<span class="p">)</span>
</code></pre></div>    </div>
    <p>这将在<code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_BINARY_DIR/include</code>目录下生成<code class="language-plaintext highlighter-rouge">config.h</code>文件。</p>
  </li>
</ol>

<p>通常情况下,建议使用相对路径或<code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_BINARY_DIR</code>指定输出文件路径,这样可以确保生成的文件位于构建目录的子目录中,方便管理和清理。 使用绝对路径需要格外小心,以免将生成的文件直接写入系统目录。
总之,<code class="language-plaintext highlighter-rouge">configure_file</code>输出文件的具体路径由第二个参数(输出文件路径)决定,开发者需要根据项目需求明智地选择合适的路径。</p>

<h3 id="target_include_directories">target_include_directories</h3>
<p><code class="language-plaintext highlighter-rouge">target_include_directories</code>是CMake中一个非常重要的命令,它用于为特定的目标添加包含目录(include directories)。包含目录指的是编译器在编译源代码时查找头文件的路径。</p>

<p>该命令的基本语法如下:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_include_directories</span><span class="p">(</span>&lt;target&gt;
                           [SYSTEM] [BEFORE]
                           &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]
                           [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]<span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;target&gt;</code> 是必需参数,指定要为哪个目标添加包含目录。</li>
  <li><code class="language-plaintext highlighter-rouge">[SYSTEM]</code> 是一个可选参数,用于将指定的目录标记为系统包含目录,以避免特定于该目录的编译器警告。</li>
  <li><code class="language-plaintext highlighter-rouge">[BEFORE]</code> 是一个可选参数,用于在当前目标包含目录的前面添加新的目录。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;INTERFACE|PUBLIC|PRIVATE&gt;</code> 是必需参数,指定了作用域:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">INTERFACE</code>: 添加的目录将作为接口包含目录,对于依赖于该目标的其他目标可见。</li>
      <li><code class="language-plaintext highlighter-rouge">PUBLIC</code>: 添加的目录是当前目标和依赖于当前目标的其他目标的公共包含目录。</li>
      <li><code class="language-plaintext highlighter-rouge">PRIVATE</code>: 添加的目录只用于当前目标的源文件编译。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">[items1...]</code> 是一个或多个包含目录的路径,可以使用相对路径或绝对路径。</li>
</ul>

<p>通过使用不同的作用域,我们可以很好地控制包含目录的可见性,避免头文件污染和冲突。一般情况下:</p>
<ul>
  <li>对于项目自身的头文件,应该使用<code class="language-plaintext highlighter-rouge">PRIVATE</code>作用域。</li>
  <li>对于外部库的头文件,应该使用<code class="language-plaintext highlighter-rouge">INTERFACE</code>作用域,方便依赖项目正确包含头文件。</li>
  <li>对于需要在多个目标之间共享的头文件,可以使用<code class="language-plaintext highlighter-rouge">PUBLIC</code>作用域。</li>
</ul>

<p>示例:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 将当前源码目录作为包含目录添加到 myTarget 目标</span>
<span class="nb">target_include_directories</span><span class="p">(</span>myTarget PRIVATE <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span><span class="p">)</span>

<span class="c1"># 将系统目录 /usr/include 作为接口包含目录添加到 myTarget 目标</span>
<span class="nb">target_include_directories</span><span class="p">(</span>myTarget INTERFACE SYSTEM /usr/include<span class="p">)</span>

<span class="c1"># 将外部库头文件目录作为接口包含目录添加到 myTarget 目标</span>
<span class="nb">target_include_directories</span><span class="p">(</span>myTarget INTERFACE 
                           $&lt;BUILD_INTERFACE:<span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/external/include&gt;
                           $&lt;INSTALL_INTERFACE:include&gt;<span class="p">)</span>
</code></pre></div></div>

<p>正确使用<code class="language-plaintext highlighter-rouge">target_include_directories</code>命令对于避免头文件相关的编译错误、防止头文件被无意包含等都是非常重要的。在编写CMake脚本时,请务必合理设置包含目录,特别是对于外部库和接口包含目录的处理。</p>

<h3 id="cmake-内置路径变量">cmake 内置路径变量</h3>
<p>cmake 中有一些常用的内置项目路径变量</p>
<h4 id="project_binary_dir">PROJECT_BINARY_DIR</h4>
<p><code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>是CMake中的一个内置变量,表示构建目录的顶层路径。</p>

<p>具体来说,<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>变量指向的是在运行CMake时通过命令行参数<code class="language-plaintext highlighter-rouge">-B</code>或内部选项<code class="language-plaintext highlighter-rouge">--build-dir</code>指定的构建目录,如果没有显式指定,则使用当前目录。</p>

<p>比如,如果我们在<code class="language-plaintext highlighter-rouge">/path/to/src</code>目录下运行:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake -B /path/to/build
</code></pre></div></div>

<p>那么<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>的值就是<code class="language-plaintext highlighter-rouge">/path/to/build</code>。</p>

<p>这个变量在CMake脚本中有几个常见的用途:</p>

<ol>
  <li><strong>指定生成文件的输出位置</strong>
通常一些由<code class="language-plaintext highlighter-rouge">configure_file</code>生成的文件会放置在<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>或其子目录下,方便与源码区分。
例如:
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">configure_file</span><span class="p">(</span>config.in <span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span>/config.out<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>指定中间文件和目标文件的输出位置</strong>
有些CMake命令需要指定输出路径,可以使用<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>作为基准路径。</p>
  </li>
  <li>
    <p><strong>定位外部项目和依赖</strong>
外部项目或者依赖库的路径有时候需要相对于<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>来指定。</p>
  </li>
  <li><strong>CMake调试和测试</strong>
在编写和调试CMake脚本时,知道<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>的值对于检查生成的中间文件很有帮助。</li>
</ol>

<p>总的来说,<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>变量提供了构建目录的位置信息,是CMake脚本中非常重要的一个内置变量,可以帮助我们正确定位构建产物和依赖项的位置。在编写CMakeLists.txt时合理使用它有助于保持项目组织结构的清晰和可维护性。</p>

<h4 id="cmake_source_dir">CMAKE_SOURCE_DIR</h4>
<p>表示项目根源码目录的完整路径。这个变量在运行CMake时就被设置好了,对于绝大多数项目来说,它的值就是包含顶层<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>文件的目录。</p>

<h4 id="cmake_current_source_dir">CMAKE_CURRENT_SOURCE_DIR</h4>
<p>表示当前正在处理的<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>所在的目录。在递归遍历子目录时,该变量会随之改变,指向当前子目录。</p>

<h4 id="cmake_current_binary_dir">CMAKE_CURRENT_BINARY_DIR</h4>
<p>表示当前正在处理的<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>生成的目标文件和其他构建产物的存放路径。它是<code class="language-plaintext highlighter-rouge">PROJECT_BINARY_DIR</code>的一个子目录。</p>

<h4 id="cmake_current_list_dir">CMAKE_CURRENT_LIST_DIR</h4>
<p>表示当前正在处理的<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>文件所在的完整路径。它与<code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_SOURCE_DIR</code>的区别在于,后者获取的是源码目录,而<code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_LIST_DIR</code>直接获取<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>所在目录。</p>

<h4 id="project_source_dir">PROJECT_SOURCE_DIR</h4>
<p>与<code class="language-plaintext highlighter-rouge">CMAKE_SOURCE_DIR</code>类似,表示顶层源码目录,但针对的是通过<code class="language-plaintext highlighter-rouge">project()</code>命令定义的项目。</p>

<h4 id="project_binary_dir-1">PROJECT_BINARY_DIR</h4>
<p>与<code class="language-plaintext highlighter-rouge">CMAKE_BINARY_DIR</code>类似,表示顶层构建目录,但针对的是通过<code class="language-plaintext highlighter-rouge">project()</code>命令定义的项目。</p>]]></content><author><name></name></author><category term="C++" /><category term="cmake" /><summary type="html"><![CDATA[本文是我学习 cmake 官方教程的笔记，我在官方教程的基础上，对其中的知识点做了展开描述。]]></summary></entry><entry><title type="html">【学习 cmake step2】 创建公共库(library)</title><link href="https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step2.html" rel="alternate" type="text/html" title="【学习 cmake step2】 创建公共库(library)" /><published>2024-01-04T00:00:00+08:00</published><updated>2024-01-04T00:00:00+08:00</updated><id>https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step2</id><content type="html" xml:base="https://mengman.github.io/c++/cmake/2024/01/04/CMake-by-examples-Step2.html"><![CDATA[<p>目标：学习在项目中如何构建和使用一个公共库(library)。</p>

<ol>
  <li>在项目子文件夹中创建一个公共库，名字叫做 <code class="language-plaintext highlighter-rouge">MathFunctions</code> 供项目使用。</li>
  <li>提供一个编译选项，来选择是使用 <code class="language-plaintext highlighter-rouge">MathFunctions</code> 还是系统库。</li>
</ol>

<h1 id="源码实现">源码实现</h1>

<p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20a%20Library.html">Step 2: Adding a Library</a></p>

<p><strong>目标1</strong> 创建 MathFunctions 公共库 
Step2/MathFunctions/CMakeLists.txt</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># TODO 1: 添加子目录名字叫做 "MathFunctions" 的库 (但是没有指定库的类型)</span>
<span class="nb">add_library</span><span class="p">(</span>MathFunctions MathFuntions.cxx mysqrt.cxx<span class="p">)</span>
</code></pre></div></div>

<p>Step2/CMakeLists.txt</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.10<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>Tutorial VERSION 1.0<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 11<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD_REQUIRED True<span class="p">)</span>
<span class="nb">configure_file</span><span class="p">(</span>Tutorial.h.in TutorialConfig.h<span class="p">)</span>

<span class="c1"># TODO 2: 添加子目录"MathFunctions"作为依赖库</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>MathFunctions<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>Tutorial tutorial.cxx<span class="p">)</span>

<span class="c1"># TODO 3: 将公共库添加到编译链接中</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>Tutorial PUBLIC MathFunctions<span class="p">)</span>
<span class="c1"># TODO 4: 添加公共库的头文件到inlucde中</span>
<span class="nb">target_include_directories</span><span class="p">(</span>
	Tutorial PUBLIC
	<span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span><span class="s2">"</span>
	<span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span><span class="s2">/MathFunctions"</span>
<span class="p">)</span>
</code></pre></div></div>

<p><strong>目标2</strong> 选择编译，使用自定义的 <code class="language-plaintext highlighter-rouge">sqrt</code> 函数还是 <code class="language-plaintext highlighter-rouge">std::sqrt</code>
通过添加编译参数 <code class="language-plaintext highlighter-rouge">USE_MYMATH</code> 并且将 <code class="language-plaintext highlighter-rouge">sqrt</code> 函数的实现代码 <code class="language-plaintext highlighter-rouge">mysqrt.cxx</code> 单独编译成一个公共库 <code class="language-plaintext highlighter-rouge">SqrtLibrary</code> 来实现。
Step2/MathFunctions/CMakeLists.txt</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># TODO 1: 添加子目录名字叫做 "MathFunctions" 的库 (但是没有指定库的类型)</span>
<span class="c1"># add_library(MathFunctions MathFuntions.cxx mysqrt.cxx)</span>

<span class="c1"># TODO 14: 将 mysqrt.cxx 从 MathFunctions 中移除</span>
<span class="c1"># 注意这里定义 MathFunctions 为动态库</span>
<span class="nb">add_library</span><span class="p">(</span>MathFunctions SHARED MathFuntions.cxx<span class="p">)</span>

<span class="c1"># TODO 7: 创建控制变量 USE_MYMATH 默认值为 ON</span>
<span class="nb">option</span><span class="p">(</span>USE_MYMATH <span class="s2">"Use tutorial provided math implementation"</span> ON<span class="p">)</span>

<span class="c1"># TODO 8: 设置编译变量 'USE_MYMATH' 来控制代码编译内容</span>
<span class="nb">if</span> <span class="p">(</span>USE_MYMATH<span class="p">)</span>
	<span class="nb">target_compile_definitions</span><span class="p">(</span>MathFunctions PRIVATE <span class="s2">"USE_MYMATH"</span><span class="p">)</span>
<span class="nb">endif</span> <span class="p">()</span>

<span class="nb">if</span> <span class="p">(</span>USE_MYMATH<span class="p">)</span>
	<span class="c1"># TODO 12: 将自己实现的 mysqrt.cxx 定义为公共库 SqrtLibrary</span>
	<span class="c1"># 定义为静态库</span>
	<span class="nb">add_library</span><span class="p">(</span>SqrtLibrary STATIC mysqrt.cxx<span class="p">)</span>
	<span class="c1"># 或者定义为动态库</span>
	<span class="c1"># add_library(SqrtLibrary SHARED mysqrt.cxx)</span>

	<span class="c1"># TODO 13： 添加编译链接</span>
	<span class="nb">target_link_libraries</span><span class="p">(</span>MathFunctions PRIVATE SqrtLibrary<span class="p">)</span>
<span class="nb">endif</span> <span class="p">()</span>
</code></pre></div></div>

<p>Step2/MathFunctions/MathFunctions.cxx</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"MathFunctions.h"</span><span class="cp">
</span><span class="c1">// TODO 11: 添加标准库 cmath</span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span>
<span class="c1">// TODO 10: 根据编译参数引入 mysqrt.h</span>
<span class="cp">#ifdef USE_MYMATH
#include</span> <span class="cpf">"mysqrt.h"</span><span class="cp">
#endif
</span>
<span class="k">namespace</span> <span class="n">mathfunctions</span> <span class="p">{</span>
<span class="kt">double</span> <span class="n">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// TODO 9: 根据编译参数 USE_MYMATH 来选择具体调用的 sqrt 函数</span>
<span class="cp">#ifdef USE_MYMATH
</span><span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">mysqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="cp">#else
</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="cp">#endif
</span>
<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="命令讲解">命令讲解</h1>

<h2 id="add_library">add_library</h2>

<p><code class="language-plaintext highlighter-rouge">add_library</code>命令在CMake中用于定义一个库目标。它有以下几种使用方式:</p>

<ol>
  <li><strong>静态库</strong>
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>lib_name [STATIC] source1.cpp source2.cpp ...<span class="p">)</span>
</code></pre></div>    </div>
    <p>这将使用<code class="language-plaintext highlighter-rouge">source1.cpp</code>、<code class="language-plaintext highlighter-rouge">source2.cpp</code>等源文件创建一个名为<code class="language-plaintext highlighter-rouge">lib_name</code>的静态库。</p>
  </li>
  <li><strong>共享库(动态库)</strong>
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>lib_name [SHARED] source1.cpp source2.cpp ...<span class="p">)</span>
</code></pre></div>    </div>
    <p>这将使用<code class="language-plaintext highlighter-rouge">source1.cpp</code>、<code class="language-plaintext highlighter-rouge">source2.cpp</code>等源文件创建一个名为<code class="language-plaintext highlighter-rouge">lib_name</code>的共享库。</p>
  </li>
  <li><strong>对象库</strong>
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>lib_name OBJECT source1.cpp source2.cpp ...<span class="p">)</span>
</code></pre></div>    </div>
    <p>这将编译<code class="language-plaintext highlighter-rouge">source1.cpp</code>、<code class="language-plaintext highlighter-rouge">source2.cpp</code>等源文件,但不会创建库文件,而是创建一个对象库,以便于后续链接到其他目标。</p>
  </li>
  <li><strong>导入库</strong>
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>lib_name [STATIC | SHARED | OBJECT] IMPORTED [IMPORTED_LOCATION]<span class="p">)</span>
</code></pre></div>    </div>
    <p>这种方式用于导入一个预先构建好的库,而非使用源代码构建库。需要指定库的类型(<code class="language-plaintext highlighter-rouge">STATIC</code>、<code class="language-plaintext highlighter-rouge">SHARED</code>或<code class="language-plaintext highlighter-rouge">OBJECT</code>)以及它的位置。
在定义库目标之后,你可以使用<code class="language-plaintext highlighter-rouge">target_link_libraries</code>命令将其链接到可执行目标或其他库目标。同时,也可以使用<code class="language-plaintext highlighter-rouge">set_target_properties</code>等命令设置库目标的属性。</p>
  </li>
</ol>

<p>在使用 <code class="language-plaintext highlighter-rouge">add_library</code> 来创建库时，如果不指定库的类型(STATIC, SHARED)， cmake 可能根据不同操作系统平台，默认指定库的类型。</p>

<h2 id="add_subdirectory">add_subdirectory</h2>
<p><code class="language-plaintext highlighter-rouge">add_subdirectory</code>命令用于将另一个独立的CMakeLists.txt文件包含到当前的CMake构建中。它具有以下几个作用:</p>

<ol>
  <li><strong>包含子目录</strong>
最常见的用法是将位于子目录中的CMakeLists.txt文件包含进来。这样子目录中定义的目标(如库、可执行文件等)也会被构建。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>subdirName<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>包含外部项目</strong>
如果有一个外部项目提供了自己的CMakeLists.txt文件,我们也可以使用<code class="language-plaintext highlighter-rouge">add_subdirectory</code>命令将它包含进当前项目构建中。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>/path/to/external/project<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>指定二进制目录</strong>
<code class="language-plaintext highlighter-rouge">add_subdirectory</code>还可以指定一个二进制目录,用于存放编译生成的中间文件和目标文件。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>subdirName <span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span>/generated<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>排除构建某些组件</strong>
可以通过设置CMake变量来控制是否包含某些子目录。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">option</span><span class="p">(</span>WITH_SUBDIR <span class="s2">"Build subdirectory?"</span> ON<span class="p">)</span>
<span class="nb">if</span><span class="p">(</span>WITH_SUBDIR<span class="p">)</span>
 <span class="nb">add_subdirectory</span><span class="p">(</span>subdirName<span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li><strong>控制子目录构建行为</strong>
<code class="language-plaintext highlighter-rouge">add_subdirectory</code>还可以传递额外的参数,这些参数会被传递给子目录的顶层CMakeLists.txt文件。子目录可以使用这些参数来控制其自身的构建行为。
总之,<code class="language-plaintext highlighter-rouge">add_subdirectory</code>命令提供了一种方便的机制,将其他CMakeLists.txt文件集成到当前的构建系统中。它支持跨目录组织项目,以及复用外部项目。</li>
</ol>

<p>如果要同时指定多个包含 CMakeLists.txt 文件的子目录。
方案一： 分别使用多个add_subdirectory命令</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>subdir1<span class="p">)</span> 
<span class="nb">add_subdirectory</span><span class="p">(</span>subdir2<span class="p">)</span> 
<span class="nb">add_subdirectory</span><span class="p">(</span>subdir3<span class="p">)</span>
</code></pre></div></div>
<p>使用这种方式,每个子目录会被分别包含,CMake会按照命令出现的顺序逐个处理子目录。这在处理有依赖关系的子目录时很有用。</p>

<p>方案二： 使用单个add_subdirectory命令并传递多个子目录</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>subdir1 subdir2 subdir3<span class="p">)</span>
</code></pre></div></div>
<p>这种方式更加简洁,一行就可以包含多个子目录。CMake会按照参数列表的顺序依次处理每个子目录。
不过需要注意,第二种方式中,所有子目录会被视为在同一级别,CMake不会去分析它们之间是否存在依赖关系。如果存在依赖关系,需要确保参数列表中的顺序是正确的。
另外,无论采用哪种方式,被包含的子目录都需要包含一个CMakeLists.txt文件。如果某个子目录不包含该文件,CMake会直接忽略它。</p>

<h2 id="target_link_libraries">target_link_libraries</h2>
<p><code class="language-plaintext highlighter-rouge">target_link_libraries</code>命令是CMake中用于为目标(executable或library)链接所需库的关键命令。它的主要作用如下:</p>

<ol>
  <li><strong>链接库目标</strong>
可以链接之前使用<code class="language-plaintext highlighter-rouge">add_library</code>定义的库目标。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>mylib src1.cpp<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>myapp main.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>myapp mylib<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>链接系统库</strong>
可以链接系统库,如pthread、m等。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span><span class="p">(</span>mytarget pthread m<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>链接第三方库</strong>
可以链接第三方库,如boost、gtest等。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span><span class="p">(</span>mytarget /path/to/third_party_lib.so<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>链接导入库</strong>
可以链接使用<code class="language-plaintext highlighter-rouge">add_library(... IMPORTED)</code>导入的预构建库。</p>
  </li>
  <li><strong>控制链接选项</strong>
可以传递链接选项,如链接时间优化选项(-flto)、静态/动态链接选项(-static)等。
    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span><span class="p">(</span>mytarget -flto -static<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>传递链接依赖</strong>
如果A链接了B和C,当D链接A时,B和C也会被传递性地链接进来。
<code class="language-plaintext highlighter-rouge">target_link_libraries</code>是非常灵活和强大的,几乎所有链接目标库的情况都需要使用它。正确使用它可以确保目标正确构建和链接所需的所有依赖库。
此外,<code class="language-plaintext highlighter-rouge">target_link_libraries</code>还支持传递链接接口,即被链接目标所暴露的包含目录、链接选项等,这使得构建更加模块化。
总之,<code class="language-plaintext highlighter-rouge">target_link_libraries</code>是CMake中管理目标库依赖关系的核心命令,熟练掌握它对于跨平台C++构建至关重要。</li>
</ol>

<h2 id="option">option</h2>
<p><code class="language-plaintext highlighter-rouge">option</code>命令在CMake中用于定义一个选项变量,这个变量可以在运行cmake时或者通过其他界面(如cmake-gui)进行设置。它的语法如下:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">option</span><span class="p">(</span>&lt;option_variable&gt; <span class="s2">"help_string"</span> [value]<span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;option_variable&gt;</code>是将要定义的选项变量名。</li>
  <li><code class="language-plaintext highlighter-rouge">"help_string"</code>是一个描述该选项作用的帮助字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">[value]</code>是可选的,用于指定默认值。如果省略,默认为OFF。</li>
</ul>

<p>例如:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">option</span><span class="p">(</span>WITH_OPENGL <span class="s2">"Build with OpenGL support"</span> ON<span class="p">)</span>
</code></pre></div></div>
<p>这条命令定义了一个名为<code class="language-plaintext highlighter-rouge">WITH_OPENGL</code>的选项变量,描述为”Build with OpenGL support”,默认值为ON。</p>

<p>在定义选项后,可以在配置CMake时通过命令行或其他界面设置该选项的值。例如:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake -DWITH_OPENGL=OFF ..
</code></pre></div></div>
<p>或者通过cmake-gui等图形界面进行设置。</p>

<p>定义的选项变量可以在CMake脚本中使用,通常用于条件编译。比如:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">if</span><span class="p">(</span>WITH_OPENGL<span class="p">)</span>
    <span class="nb">add_definitions</span><span class="p">(</span>-DUSE_OPENGL<span class="p">)</span>
    ...
<span class="nb">else</span><span class="p">()</span>
    ...
<span class="nb">endif</span><span class="p">()</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">option</code>命令为CMake构建系统提供了灵活性,允许用户根据需要启用或禁用某些特性。它使得一次配置就可以构建出不同的版本。开发人员也可以通过设置默认值,方便地控制构建行为。</p>

<p><code class="language-plaintext highlighter-rouge">option</code> 与 <code class="language-plaintext highlighter-rouge">set</code> 命令对比</p>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>option 命令</th>
      <th>set 命令</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>定义方式</td>
      <td>定义布尔选项变量,只能取 ON 或 OFF 值</td>
      <td>可定义任意类型变量,包括布尔、字符串、列表等</td>
    </tr>
    <tr>
      <td>用户可操作性</td>
      <td>可在运行 CMake 时通过命令行或界面设置</td>
      <td>无法在运行时直接修改,需在 CMakeLists.txt 中硬编码</td>
    </tr>
    <tr>
      <td>默认值</td>
      <td>如果未指定,默认为 OFF</td>
      <td>必须显式指定值</td>
    </tr>
    <tr>
      <td>帮助信息</td>
      <td>可添加描述选项用途的帮助字符串</td>
      <td>无法添加帮助信息</td>
    </tr>
    <tr>
      <td>主要目的</td>
      <td>为用户提供配置选项,控制构建行为</td>
      <td>通用变量定义,用途广泛</td>
    </tr>
  </tbody>
</table>

<p>两者虽然都可以定义变量,但 <code class="language-plaintext highlighter-rouge">option</code> 命令更侧重于为用户提供可配置的选项,而 <code class="language-plaintext highlighter-rouge">set</code> 命令则更加通用和灵活。合理使用两者有助于提高 CMake 构建系统的可用性和可维护性。</p>

<h2 id="target_compile_definitions">target_compile_definitions</h2>

<p><code class="language-plaintext highlighter-rouge">target_compile_definitions</code> 是 CMake 中用于为特定目标(target)添加编译定义的命令,通常用于条件编译。它的语法如下:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_compile_definitions</span><span class="p">(</span>&lt;target&gt;
                           &lt;INTERFACE|PUBLIC|PRIVATE&gt;
                           [items1...]
                           [...]
                           <span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;target&gt;</code> 是要添加编译定义的目标,可以是由 <code class="language-plaintext highlighter-rouge">add_executable</code>、<code class="language-plaintext highlighter-rouge">add_library</code> 等命令创建的可执行目标或库目标。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;INTERFACE|PUBLIC|PRIVATE&gt;</code> 用于指定编译定义的作用域:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">INTERFACE</code>: 将定义传播给依赖于该目标的其他目标。</li>
      <li><code class="language-plaintext highlighter-rouge">PUBLIC</code>: 将定义传播给依赖于该目标的其他目标,并将其合并到依赖于上一个目标的目标中。</li>
      <li><code class="language-plaintext highlighter-rouge">PRIVATE</code>: 定义仅用于该目标本身,不会传播到其他目标。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">[items...]</code> 是一个或多个编译定义的列表,每个定义可以是 <code class="language-plaintext highlighter-rouge">KEY=VALUE</code> 形式或只指定 <code class="language-plaintext highlighter-rouge">KEY</code>。</li>
</ul>

<p>例如:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span><span class="p">(</span>mylib src1.cpp src2.cpp<span class="p">)</span>
<span class="nb">target_compile_definitions</span><span class="p">(</span>mylib
  PRIVATE 
    DEBUG_LEVEL=2   <span class="c1"># 为mylib指定DEBUG_LEVEL=2</span>
    USE_CUSTOM_ALLOC <span class="c1"># 为mylib启用USE_CUSTOM_ALLOC</span>
  PUBLIC   
    MYLIB_EXPORTS   <span class="c1"># 将MYLIB_EXPORTS传播到依赖于mylib的其他目标</span>
<span class="p">)</span>
</code></pre></div></div>

<p>添加到目标上的编译定义会被传递给编译器,在源文件编译时生效。它们主要用于:</p>
<ol>
  <li>条件编译代码</li>
  <li>定义构建配置相关的宏</li>
  <li>控制库或程序的行为
通过 <code class="language-plaintext highlighter-rouge">target_compile_definitions</code> 可以清晰地管理每个目标所需的编译定义,使构建系统更加模块化和可维护。相比在源代码中使用 <code class="language-plaintext highlighter-rouge">#define</code>、<code class="language-plaintext highlighter-rouge">-D</code> 编译器标志等方式,它更加集中和便于控制。</li>
</ol>

<p>对比 <code class="language-plaintext highlighter-rouge">target_compile_definitions</code> 和 <code class="language-plaintext highlighter-rouge">add_definitions</code></p>

<table>
  <thead>
    <tr>
      <th>对比项</th>
      <th>target_compile_definitions</th>
      <th>add_definitions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>作用范围</td>
      <td>只针对指定的目标(target)</td>
      <td>对所有目标都生效,全局范围</td>
    </tr>
    <tr>
      <td>传递性</td>
      <td>可通过<code class="language-plaintext highlighter-rouge">INTERFACE</code>、<code class="language-plaintext highlighter-rouge">PUBLIC</code>传递给依赖目标</td>
      <td>不会传递给依赖目标</td>
    </tr>
    <tr>
      <td>可重用性</td>
      <td>模块化,更利于代码重用</td>
      <td>全局性,不利于代码重用</td>
    </tr>
    <tr>
      <td>生命周期</td>
      <td>与目标生命周期相同,更易管理</td>
      <td>在整个构建过程中都有效,难以管理</td>
    </tr>
    <tr>
      <td>作用时间</td>
      <td>立即为指定目标添加编译定义</td>
      <td>直到遇到第一个目标定义时才生效</td>
    </tr>
  </tbody>
</table>

<p>总的来说,<code class="language-plaintext highlighter-rouge">target_compile_definitions</code>更加现代、灵活、模块化,符合CMake的目标导向设计理念,建议优先使用。而<code class="language-plaintext highlighter-rouge">add_definitions</code>是一种传统的、全局的方式,在某些简单场景下也可以使用,但不够灵活。</p>

<p>在编写CMakeLists.txt时,尽量使用<code class="language-plaintext highlighter-rouge">target_compile_definitions</code>以提高代码的可重用性和可维护性。</p>

<h2 id="与位置无关的代码--fpic">与位置无关的代码 (-fPIC)</h2>

<p>在目标2 的代码中如果将 <code class="language-plaintext highlighter-rouge">MathFunctions</code> 定义为动态库，而<code class="language-plaintext highlighter-rouge">SqrtLibrary</code> 定义为静态库，那么在编译过程中会报错：
<code>/usr/bin/ld: libSqrtLibrary.a(mysqrt.cxx.o): relocation R_X86_64_PC32 against symbol `_ZSt4cout@@GLIBCXX_3.4` can not be used when making a shared object; recompile with -fPIC</code></p>

<p><strong>先解释一下什么是 PIC</strong>
PIC 的全称是 <strong>Position-Independent Code</strong> 与位置无关的代码, 它是指这段代码在加载和执行时,可以被放置在内存的任何位置而不会产生错误。
这个概念的背景是,在现代操作系统中,进程的虚拟内存地址空间分为多个区域,不同类型的代码和数据被加载到不同的区域。而这些区域的起始地址并不是固定的,每次加载时都可能不同。如果代码中存在一些对内存地址做了绝对假设的情况,就可能导致程序在某些特定内存布局时无法正常运行。为了避免这种情况,需要生成”与位置无关的代码”(PIC)。具体来说,PIC代码在访问数据时,使用相对寻址而不是绝对地址,从而避免了对特定内存地址的依赖。编译器在生成PIC代码时,会插入一些额外的指令来计算数据的相对位置。
生成PIC代码是必要的,主要有以下几种情况:</p>
<ol>
  <li><strong>生成共享库(动态库)时</strong>,共享库被加载到内存后其地址是不确定的,必须使用PIC。</li>
  <li><strong>使用动态加载技术</strong>时,动态加载的代码也必须是PIC。</li>
  <li><strong>内核模块编程</strong>时,内核模块加载位置也是不确定的,需要PIC。</li>
  <li>某些<strong>特殊的嵌入式系统</strong>对代码的内存布局有特殊要求,也需要PIC。
可以通过给编译器传递<code class="language-plaintext highlighter-rouge">-fPIC</code>选项来生成PIC代码。生成PIC代码会带来少量的代码大小和性能开销,但在现代CPU上这个开销通常可以忽略。</li>
</ol>

<p><strong>那为什么在编译项目的时候会爆这个错误呢？</strong>
因为我们定义 <code class="language-plaintext highlighter-rouge">MathFunctions</code> 为动态库，而 <code class="language-plaintext highlighter-rouge">SqrtLibrary</code> 为静态库；如果<strong>最终的可执行程序</strong>或者<strong>静态库</strong>需要链接<strong>动态库</strong>, 则其中的所有代码都需要是位置无关代码(PIC)。这是因为动态库在加载时,其位置是不确定的,如果可执行程序中有非PIC代码,就会导致动态库无法正常加载和运行。</p>

<p>另外，从glibc 2.23版本开始,链接器开始强制要求静态库必须是PIC格式的,否则会拒绝链接。之前的glibc版本也建议使用PIC静态库,但不是强制的。这一变化主要是为了执行保护和加固功能。因此,如果要在Linux系统上构建一个可执行程序,并且该程序需要链接动态库,或者要链接glibc 2.23+版本,那么所有被链接进来的静态库都必须是PIC格式的。如果之前的静态库是以默认非PIC方式编译的,就需要加上<code class="language-plaintext highlighter-rouge">-fPIC</code>选项重新编译,生成PIC格式的静态库。这一要求不仅来自于动态库加载的需求,也是glibc对静态库格式的限制要求。</p>

<p><strong>解决方法</strong></p>
<ol>
  <li>将 <code class="language-plaintext highlighter-rouge">MathFunctions</code> 和 <code class="language-plaintext highlighter-rouge">SqrtLibrary</code>  都定义为动态库</li>
  <li>为 cmake 添加上参数  <code class="language-plaintext highlighter-rouge">-DCMAKE_POSITION_INDEPENDENT_CODE=ON</code></li>
  <li>通过 <code class="language-plaintext highlighter-rouge">set_target_properties(SqrtLibrary PROPERTIES POSITION_INDEPENDENT_CODE)</code>  单独将 SqrtLibrary  设置为支持 PIC。</li>
</ol>]]></content><author><name></name></author><category term="C++" /><category term="cmake" /><summary type="html"><![CDATA[目标：学习在项目中如何构建和使用一个公共库(library)。]]></summary></entry><entry><title type="html">机器学习项目基础设施</title><link href="https://mengman.github.io/machinelearning/deeplearning/softwareenginer/2021/06/14/machine-learning-infrastructures.html" rel="alternate" type="text/html" title="机器学习项目基础设施" /><published>2021-06-14T00:00:00+08:00</published><updated>2021-06-14T00:00:00+08:00</updated><id>https://mengman.github.io/machinelearning/deeplearning/softwareenginer/2021/06/14/machine-learning-infrastructures</id><content type="html" xml:base="https://mengman.github.io/machinelearning/deeplearning/softwareenginer/2021/06/14/machine-learning-infrastructures.html"><![CDATA[<h1 id="机器学习项目基础设施">机器学习项目基础设施</h1>

<p>机器学习过程可以大体上分为三个部分数据管理、模型训练与生产部署。</p>

<p><img src="/assets/ml_infrastructure.png" alt="ml_infrastructure" /></p>

<p><em>图片来自课程 <a href="[Lecture 6: Infrastructure &amp; Tooling - Full Stack Deep Learning](https://fullstackdeeplearning.com/spring2021/lecture-6/)">Full Stack Deep Learning</a></em></p>

<h2 id="数据管理">数据管理</h2>

<h3 id="数据源sources">数据源(sources)</h3>

<p>数据源负责数据的存储与数据格式，常用的存储方式包括本地的文件系统、服务器上的对象存储。常用的数据格式有HDF5、Parquet 等。</p>

<h3 id="数据湖数据仓库">数据湖/数据仓库</h3>

<p>负责管理记录数据集，常见的数据湖软件/服务包括有：snowflake、databricks</p>

<h3 id="数据处理">数据处理</h3>

<p>数据处理有很多并行计算的框架</p>

<ul>
  <li>apache airflow：由 Airbnb 开源的计算框架，可以用来构建 DAG 计算图，实现数据的细粒度并行处理。</li>
  <li>spark：老牌数据流处理框架，支持 Java、Python 在内的多种语言。</li>
  <li>Dagster：和 airflow 一样也是一个数据计算的编排框架</li>
</ul>

<h3 id="数据分析">数据分析</h3>

<ul>
  <li>pandas：最常用的数据处理框架</li>
  <li>rapis: 基本上就是支持 GPU 计算的pandas</li>
</ul>

<h3 id="版本控制">版本控制</h3>

<ul>
  <li>DVC：全名叫 Data version control，专门负责数据版本控制还有模型版本控制的工具，它的操作基于git，通过对大文件的管理来实现版本控制。</li>
  <li>Pachyderm:  Pachyderm 不只是单纯的数据版本控制，还提供了数据生成pipeline的管理。</li>
</ul>

<h2 id="模型训练">模型训练</h2>

<h3 id="计算设备服务">计算设备&amp;服务</h3>

<p>本地的计算设备、各种云计算服务</p>

<h3 id="资源管理">资源管理</h3>

<p>Docke、sdetermined AI 等</p>

<h3 id="计算框架分布式训练框架">计算框架&amp;分布式训练框架</h3>

<p>深度学习框架：Pytorch、 tensorflow</p>

<p>深度学习库：<a href="http://fast.ai">fast.ai</a>、keras</p>

<p>分布式计算框架：RAY 等</p>

<h3 id="实验管理">实验管理</h3>

<ul>
  <li>TensorBoard：tensorflow 的可视化实验管理模块，现在独立出来，甚至 pytorch 都对他进行了支持。但是它没有对多个实验的管理能力。</li>
  <li>mlflow：是一款开源的试验管理工具，最大的特点是提供本地的实验管理功能，没有各种收费的云服务版本。</li>
  <li>weights &amp; biases: 是一款综合的实验管理工具，它除了提供实验追踪，还提供了数据可视化、模型调优等功能。但是 W&amp;B 是一款基于网络服务的实验管理工具。</li>
  <li><a href="http://Neptune.ai">Neptune.ai</a> <a href="http://comet.ml">comet.ml</a>:  也是基于网络服务的实验管理工具。</li>
</ul>

<h3 id="超参调试">超参调试</h3>

<ul>
  <li>SIGOPT</li>
  <li>Determined AI</li>
  <li>Weight &amp; Biases</li>
  <li>Tune</li>
</ul>

<h2 id="模型部署">模型部署</h2>

<h3 id="ci测试">CI&amp;测试</h3>

<ul>
  <li>Jenkins</li>
  <li>Gitlab CI</li>
  <li>Circle CI</li>
</ul>

<h3 id="边缘设备部署">边缘设备部署</h3>

<ul>
  <li>Nvidia TensorRT</li>
  <li>TensorFlow Lite</li>
</ul>]]></content><author><name></name></author><category term="machinelearning" /><category term="deeplearning" /><category term="softwareenginer" /><summary type="html"><![CDATA[机器学习项目基础设施 机器学习过程可以大体上分为三个部分数据管理、模型训练与生产部署。 图片来自课程 Full Stack Deep Learning 数据管理 数据源(sources) 数据源负责数据的存储与数据格式，常用的存储方式包括本地的文件系统、服务器上的对象存储。常用的数据格式有HDF5、Parquet 等。 数据湖/数据仓库 负责管理记录数据集，常见的数据湖软件/服务包括有：snowflake、databricks 数据处理 数据处理有很多并行计算的框架 apache airflow：由 Airbnb 开源的计算框架，可以用来构建 DAG 计算图，实现数据的细粒度并行处理。 spark：老牌数据流处理框架，支持 Java、Python 在内的多种语言。 Dagster：和 airflow 一样也是一个数据计算的编排框架 数据分析 pandas：最常用的数据处理框架 rapis: 基本上就是支持 GPU 计算的pandas 版本控制 DVC：全名叫 Data version control，专门负责数据版本控制还有模型版本控制的工具，它的操作基于git，通过对大文件的管理来实现版本控制。 Pachyderm: Pachyderm 不只是单纯的数据版本控制，还提供了数据生成pipeline的管理。 模型训练 计算设备&amp;服务 本地的计算设备、各种云计算服务 资源管理 Docke、sdetermined AI 等 计算框架&amp;分布式训练框架 深度学习框架：Pytorch、 tensorflow 深度学习库：fast.ai、keras 分布式计算框架：RAY 等 实验管理 TensorBoard：tensorflow 的可视化实验管理模块，现在独立出来，甚至 pytorch 都对他进行了支持。但是它没有对多个实验的管理能力。 mlflow：是一款开源的试验管理工具，最大的特点是提供本地的实验管理功能，没有各种收费的云服务版本。 weights &amp; biases: 是一款综合的实验管理工具，它除了提供实验追踪，还提供了数据可视化、模型调优等功能。但是 W&amp;B 是一款基于网络服务的实验管理工具。 Neptune.ai comet.ml: 也是基于网络服务的实验管理工具。 超参调试 SIGOPT Determined AI Weight &amp; Biases Tune 模型部署 CI&amp;测试 Jenkins Gitlab CI Circle CI 边缘设备部署 Nvidia TensorRT TensorFlow Lite]]></summary></entry><entry><title type="html">机器学习中的交叉熵</title><link href="https://mengman.github.io/machinelearning/math/2020/09/27/cross-entropy.html" rel="alternate" type="text/html" title="机器学习中的交叉熵" /><published>2020-09-27T14:11:00+08:00</published><updated>2020-09-27T14:11:00+08:00</updated><id>https://mengman.github.io/machinelearning/math/2020/09/27/cross-entropy</id><content type="html" xml:base="https://mengman.github.io/machinelearning/math/2020/09/27/cross-entropy.html"><![CDATA[<h1 id="机器学习中的交叉熵">机器学习中的交叉熵</h1>

<p>交叉熵损失函数是机器学习分类问题中最常用的一个损失函数。但是很多人对于“交叉熵”的概念缺乏理解。本文的目的是希望能够通俗易懂的解释清楚 “熵”， “交叉熵” 和 “KL-散度” 这三个相关的概念。</p>

<h2 id="信息论中的熵">信息论中的“熵”</h2>

<p>“熵” (entropy) 这个概念在热力学中表示一个系统的无序程度，熵越大系统就越混乱。1948年香农在其发表的《通信的数学理论》论文中给出了”信息熵“的定义：信息熵是随机事件不确定性的度量。信息熵与热力学熵有着紧密的内在联系，不过在本文中所讨论的熵都是指信息熵。</p>

<h3 id="有效信息长度">有效信息长度</h3>

<p>为了能更好的解释信息熵，我们先来看一个例子。有一个气象监测站，通过检测某地的气象数据，能给出第二天的天气预测。气象站需要将预测结果网络发送给气象中心。如果当地只有两种天气一种是晴天，一种是雨天，那么气象站如何能够高效的发送预测结果呢？最简单的情况下，气象站可以将预测结果以汉字的形式发送出去。如果预测是晴天就发送”晴天“，如果是雨天就发送”雨天“。我们知道一个汉字在计算机中通常的编码长度是 2 byte，也就是 8 bit，那么这两个汉字就是 16 bit。为了能更高效的发送信息，我们可以对信息进行编码，用 0 来表示晴天，1 来表示雨天。那么我们需要发送的信息长度就只有 1 bit 了。对于原来长度为 16 bit 的信息来说，它<strong>真正有效的信息长度</strong>其实只有 1 bit。</p>

<p><img src="/assets/entropy1.png" alt="weather_2" /></p>

<p>那如果当地天气有8种情况，我们需要多少长度的消息才能发送预测结果呢？答案很简单：\(2^3=8\) ，我们只需要3个 bit 就能发送8种天气。在计算机中对于任意n种分类情况，我们只需要 \(log_2 (n)\) 长度的编码信息就可以把所有的情况进行编码。</p>

<p><img src="/assets/entropy2.png" alt="c" /></p>

<h3 id="信息熵">信息熵</h3>

<p>我们知道在现实中，第二天出现什么天气的概率不是均等的，在夏天出现晴天和雨天的概率比较大，而出现雪天的概率很小；而在冬天出现雨天的概率较小，出现雪天的概率较大。在第一个例子中如果晴天的概率是 75%， 雨天的概率是 25%，那么消息的长度应该是多少呢？在计算消息长度之前，我们需要先介绍“熵减因子”(reduction factor)的概念。按照香农在论文中提出：</p>

<blockquote>
  <p>每发送1个bit的有效信息，能减少了接收者2个因子的不确定性。</p>
</blockquote>

<p><strong>熵减因子</strong> m 与有<strong>效消息长度</strong> u 之间的关系是： \(2^u=m\)</p>

<p>在已知事件概率的情况下，熵减因子 m 与概率 p 的关系是： \(\frac{1}{p}=m\)</p>

<p>基于熵减因子与概率的关系，我们可以根据概率 p 推断出有效信息的长度 u 的关系:  \(-log_2{p} = u\)</p>

<p><img src="/assets/entropy4.png" alt="wheather_4" /></p>

<p>现在我们可以回答之前提出的问题了。</p>

<p><strong>晴天的有效信息长度</strong>  \(m_s = -log_2{p_s} = -log_2{0.75} = 0.41\)</p>

<p><strong>雨天的有效信息长度</strong> \(m_r = -log_2{p_r} = -log_2{0.25} = 2\)</p>

<p><strong>平均有效信息长度</strong> \(m_{avg} = p_s * (-log_2{p_s}) + p_r * (-log_2{p_r}) = 0.75 * 0.41 + 0.25 * 2 = 0.81\)</p>

<p>平均有效信息长度又被称为<strong>信息熵</strong> , 数学定义为：</p>

\[\text{Entropy},H(p) = - \sum{p(i)*log(p(i))}\]

<p>我们按照现实情况，分别给第二个例子中8种天气加一个概率。</p>

<p><img src="/assets/entropy3.png" alt="weather_8_prob" /></p>

<p>按照信息熵的定义，我们可以计算出此时的信息熵：</p>

\[\begin{aligned} 
\text{Entropy} &amp; = -0.35 * log_2{0.35} -0.35 * log_2{0.35} \\
 &amp; -0.10 * log_2{0.10} -0.10 * log_2{0.10} \\
 &amp; -0.04 * log_2{0.04} -0.04 * log_2{0.04} \\
 &amp; -0.01 * log_2{0.01} -0.01 * log_2{0.01} \\
 &amp; = 2.23
\end{aligned}\]

<p><strong>信息熵是理论上最小的平均消息长度</strong>。</p>

<h3 id="交叉熵">交叉熵</h3>

<p>通过信息熵公式我们可以计算出，理论上发送信息的最小平均长度是 2.23，上图因为多所有天气都按照3位进行编码，所以消息的平均长度是3。通过修改信息的编码方式，我们可以降低消息的平均长度。</p>

<p><img src="/assets/entropy5.png" alt="weather_9_prob" /></p>

<p>通过减小高概率天气的消息长度，增长低概率天气的消息长度，我们可以降低平均的消息长度。
\(0.35 * 2 + 0.35 * 2 + 0.1 * 3+ 0.1 * 3 + 0.04 * 4 + 0.04 * 4  + 0.01 * 4 + 0.01 * 5 = 2.42\)
<img src="/assets/entropy6.png" alt="weather_10_prob" /></p>

<p>如果我们反过来增长低概率天气的消息长度，减小大概率天气的长度，那么消息的平均长度增大。
\(0.01 * 2 + 0.01 * 2 + 0.04 * 3 + 0.04 * 3 + 0.1 * 4 + 0.1 * 4 + 0.35 * 5 + 0.35 * 5 = 4.58\)</p>

<p>上面两个例子中，我们计算信息平均长度时，是用真实的天气概率乘以我们<strong>给定的有效信息长度</strong>， 上面计算结果叫做<strong>交叉熵</strong>。</p>

<p>在已知各种情况天气的概率下，可以通过信息熵的公式计算出理论上最小的平均信息长度。但是在现实生活中，我们经常是不知道各种情况的实际概率分布的。在这种情况下，我们可以预先给出一个对于真实概率分布的一个估计（在上面的例子是预先给出一个信息长度）。
<img src="/assets/entropy7.png" alt="weather_11_prob" /></p>

<p>图中红色的概率代表天气的真实分布，而蓝色概率代表按照编码长度推算出来的对于天气概率的估计。真实的概率分布于估计概率分布之间的关系可以用<strong>交叉熵</strong>的形式表达出来。</p>

\[\text{CrossEntropy,}H(p,q) = - \sum{p(i)log(q(i))}\]

<p>通过前面的内容我们可以知道，只有<strong>估计概率越接近于真正的概率，交叉熵才会越小，当估计概率等于真实概率时，交叉熵等于信息熵。</strong></p>

<p>交叉熵公式于信息熵公式的不同之处在于，将 log 部分的概率分布替换成了<strong>预测概率分布</strong>。<strong>交叉熵大于信息熵的部分叫做Kullback-Leibler Divergence（KL散度）也叫相对熵（Relative Entropy）</strong>。</p>

\[\begin{aligned}
\text{KL-Divergence} &amp;= \text{Entropy} - \text{CrossEntropy}  \\
D_{KL}(p||q) &amp; = H(p,q) - H(p) \\
&amp; = -\sum_i{p_ilog(q_i)} - (-\sum_i{p_ilog(p_i)}) \\
&amp; = -\sum_i{p_ilog(q_i)} + \sum_i{p_ilog(p_i)} \\
&amp; = \sum_i{p_i log(\frac{p_i}{q_i})}
\end{aligned}\]

<h2 id="交叉熵在机器学习中的应用">交叉熵在机器学习中的应用</h2>

<p>由于交叉熵的性质，所以在机器学习中，交叉熵被广泛的作为<strong>分类损失函数</strong>。</p>

<p><img src="/assets/ce_loss.png" alt="ce_loss" /></p>

<p>在一个分类任务的训练过程中，我们已知目标的真实概率分布，分类器在每次的训练过程中会给出一个预测的概率分布。我们把<strong>交叉熵</strong>作为我们的目标函数，优化的方向是使得目标函数（交叉熵）最小，交叉熵只有在预测概率分布于真实概率分布一致的情况下最小，所以交叉熵非常适合作为分类任务的损失函数。</p>

<p>在信息论中<strong>信息熵</strong>，<strong>交叉熵</strong>公式中的 log 都是以 2 为底的对数，但是在机器学习中代码实现中，无论是用以10为底或者e为底都无所谓，因为对数都可以通过换底公式进行变换： \(log_e{n} = \frac{log_2{n}}{log_2{e}}\) ，因为分母始终是一个常数所以对于损失函数没有影响。</p>

<p>信息熵原本作为信息论的一个重要概念，没有想到在多年以后会在机器学习中继续大放异彩。希望通过本文的内容能理解<strong>交叉熵损失函数</strong>真正的意义。本文是根据文章 <a href="https://towardsdatascience.com/entropy-cross-entropy-and-kl-divergence-explained-b09cdae917a">Entropy, Cross-Entropy, and KL-Divergence Explained!</a> 进行的改写，读者可以阅读原文获得跟多关于交叉熵的认识。</p>]]></content><author><name></name></author><category term="machinelearning" /><category term="math" /><summary type="html"><![CDATA[机器学习中的交叉熵]]></summary></entry><entry><title type="html">pkg-config 入门</title><link href="https://mengman.github.io/c++/linux/2020/07/26/pkg-config-introduction.html" rel="alternate" type="text/html" title="pkg-config 入门" /><published>2020-07-26T00:41:00+08:00</published><updated>2020-07-26T00:41:00+08:00</updated><id>https://mengman.github.io/c++/linux/2020/07/26/pkg-config-introduction</id><content type="html" xml:base="https://mengman.github.io/c++/linux/2020/07/26/pkg-config-introduction.html"><![CDATA[<h1 id="pkg-config-入门">pkg-config 入门</h1>

<p>pkg-config 是类 Unix 操作系统上的一个库查询工具。它通过 .pc 文件来查询当前系统上已安装类库的信息。</p>

<p>下面是 OpenCV4 的 pc 文件， 文件中包含了OpenCV 库的很多元数据(metadata)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Package Information for pkg-config

prefix=/usr/local/opencv4
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir_old=${prefix}/include/opencv4/opencv
includedir_new=${prefix}/include/opencv4

Name: OpenCV
Description: Open Source Computer Vision Library
Version: 4.0.1
Libs: -L${exec_prefix}/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_cvv -lopencv_dnn_objdetect -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_line_descriptor -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_video -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core
Libs.private: -ldl -lm -lpthread -lrt
Cflags: -I${includedir_old} -I${includedir_new}
</code></pre></div></div>

<p>pc 文件中的元数据分为两种，一种是格式如 <code>prefix=**</code> 的变量，一种是格式如 <code>Name: OpenCV</code> 关键字，变量是在 pc 文件内部使用，用来帮助定义关键字；而关键字信息会导出到 pkg-config 中。</p>

<p>pkg-config 中定义了一下这些关键字</p>

<ul>
  <li>Name: 当前库的名字，它不需要全局唯一，通常它和 pc 文件的文件名保持一致。</li>
  <li>Description: 对于库的简短描述</li>
  <li>URL: 当前库的相关信息网络地址</li>
  <li>Version: 安装的版本号</li>
  <li>Requires: 列出当前库所需要的依赖，依赖库的版本信息可以使用 =, &gt;, &lt;, &lt;= 和 &gt;= 来指定。 eg. <code>Requires: OpenCV &gt;= 4.0.0</code></li>
  <li>Requires.private: 列出当前库所需要的依赖，但是这些依赖并不会暴露给应用，版本格式与 <code>Requires</code> 相同。</li>
  <li>Confilcts: 这是一个可选关键字，用来指明与当前库冲突的库</li>
  <li>Cflags: 编译当前库需要的 flags 参数。如果依赖的库不支持 pkg-config， 就可以通过此关键字来指定，如果支持 pkg-config，就应该在 <code>Requires</code> 和 <code>Requires.private</code> 中指定。</li>
  <li>Libs: 指定不支持 pkg-config 的链接依赖 flags 参数</li>
  <li>Libs.private: 同 <code>Requires.private</code> 一样，当前关键字的依赖不会暴露给应用</li>
</ul>

<p>pkg-config 默认会在 <code>/usr/lib/pkgconfig</code> 和 <code>/usr/share/pkgconfig</code> 中去加载 pc 文件，但是有些库的安装地址不在默认路径中，就需要将 pc 文件的路径添加到环境变量 <strong>PKG_CONFIG_PATH</strong> 中。</p>

<p>通过 pkg-config 可以查看安装库的版本</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkg-config <span class="nt">--modversion</span> opencv4 <span class="c"># 如果 pc 文件名与 Name 关键字不一致，这里需要输入的是文件名</span>
4.0.1
</code></pre></div></div>

<p><code>--libs</code> 可以输出编译依赖当前库的 link flags， 但是不会输出 /usr/lib 下的依赖库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkg-config <span class="nt">--libs</span> opencv4
<span class="nt">-L</span>/usr/local/opencv4/lib <span class="nt">-lopencv_gapi</span> <span class="nt">-lopencv_stitching</span> <span class="nt">-lopencv_aruco</span> <span class="nt">-lopencv_bgsegm</span> <span class="nt">-lopencv_bioinspired</span> <span class="nt">-lopencv_ccalib</span> <span class="nt">-lopencv_cvv</span> <span class="nt">-lopencv_dnn_objdetect</span> <span class="nt">-lopencv_dpm</span> <span class="nt">-lopencv_face</span> <span class="nt">-lopencv_freetype</span> <span class="nt">-lopencv_fuzzy</span> <span class="nt">-lopencv_hdf</span> <span class="nt">-lopencv_hfs</span> <span class="nt">-lopencv_img_hash</span> <span class="nt">-lopencv_line_descriptor</span> <span class="nt">-lopencv_reg</span> <span class="nt">-lopencv_rgbd</span> <span class="nt">-lopencv_saliency</span> <span class="nt">-lopencv_sfm</span> <span class="nt">-lopencv_stereo</span> <span class="nt">-lopencv_structured_light</span> <span class="nt">-lopencv_phase_unwrapping</span> <span class="nt">-lopencv_superres</span> <span class="nt">-lopencv_optflow</span> <span class="nt">-lopencv_surface_matching</span> <span class="nt">-lopencv_tracking</span> <span class="nt">-lopencv_datasets</span> <span class="nt">-lopencv_text</span> <span class="nt">-lopencv_dnn</span> <span class="nt">-lopencv_plot</span> <span class="nt">-lopencv_videostab</span> <span class="nt">-lopencv_video</span> <span class="nt">-lopencv_xfeatures2d</span> <span class="nt">-lopencv_shape</span> <span class="nt">-lopencv_ml</span> <span class="nt">-lopencv_ximgproc</span> <span class="nt">-lopencv_xobjdetect</span> <span class="nt">-lopencv_objdetect</span> <span class="nt">-lopencv_calib3d</span> <span class="nt">-lopencv_features2d</span> <span class="nt">-lopencv_highgui</span> <span class="nt">-lopencv_videoio</span> <span class="nt">-lopencv_imgcodecs</span> <span class="nt">-lopencv_flann</span> <span class="nt">-lopencv_xphoto</span> <span class="nt">-lopencv_photo</span> <span class="nt">-lopencv_imgproc</span> <span class="nt">-lopencv_core</span>
</code></pre></div></div>

<p>同时 <code>--libs</code> 也不会输出 OpenCV 的依赖，因为依赖 OpenCV 的代码并不直接依赖与OpenCV 的依赖。为了静态链接，可以加上选项 <code>--static</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkg-config <span class="nt">--libs</span> opencv4
<span class="nt">-L</span>/usr/local/opencv4/lib <span class="nt">-lopencv_gapi</span> <span class="nt">-lopencv_stitching</span> <span class="nt">-lopencv_aruco</span> <span class="nt">-lopencv_bgsegm</span> <span class="nt">-lopencv_bioinspired</span> <span class="nt">-lopencv_ccalib</span> <span class="nt">-lopencv_cvv</span> <span class="nt">-lopencv_dnn_objdetect</span> <span class="nt">-lopencv_dpm</span> <span class="nt">-lopencv_face</span> <span class="nt">-lopencv_freetype</span> <span class="nt">-lopencv_fuzzy</span> <span class="nt">-lopencv_hdf</span> <span class="nt">-lopencv_hfs</span> <span class="nt">-lopencv_img_hash</span> <span class="nt">-lopencv_line_descriptor</span> <span class="nt">-lopencv_reg</span> <span class="nt">-lopencv_rgbd</span> <span class="nt">-lopencv_saliency</span> <span class="nt">-lopencv_sfm</span> <span class="nt">-lopencv_stereo</span> <span class="nt">-lopencv_structured_light</span> <span class="nt">-lopencv_phase_unwrapping</span> <span class="nt">-lopencv_superres</span> <span class="nt">-lopencv_optflow</span> <span class="nt">-lopencv_surface_matching</span> <span class="nt">-lopencv_tracking</span> <span class="nt">-lopencv_datasets</span> <span class="nt">-lopencv_text</span> <span class="nt">-lopencv_dnn</span> <span class="nt">-lopencv_plot</span> <span class="nt">-lopencv_videostab</span> <span class="nt">-lopencv_video</span> <span class="nt">-lopencv_xfeatures2d</span> <span class="nt">-lopencv_shape</span> <span class="nt">-lopencv_ml</span> <span class="nt">-lopencv_ximgproc</span> <span class="nt">-lopencv_xobjdetect</span> <span class="nt">-lopencv_objdetect</span> <span class="nt">-lopencv_calib3d</span> <span class="nt">-lopencv_features2d</span> <span class="nt">-lopencv_highgui</span> <span class="nt">-lopencv_videoio</span> <span class="nt">-lopencv_imgcodecs</span> <span class="nt">-lopencv_flann</span> <span class="nt">-lopencv_xphoto</span> <span class="nt">-lopencv_photo</span> <span class="nt">-lopencv_imgproc</span> <span class="nt">-lopencv_core</span> <span class="nt">-ldl</span> <span class="nt">-lm</span> <span class="nt">-lpthread</span> <span class="nt">-lrt</span>
</code></pre></div></div>

<p>使用 <code>--cflags</code> pkg-config 会输出所有的编译flag， 加不加 <code>--static</code> 都一样。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pkg-config <span class="nt">--cflags</span> opencv4
<span class="nt">-I</span>/usr/local/opencv4/include/opencv4/opencv <span class="nt">-I</span>/usr/local/opencv4/include/opencv4

pkg-config <span class="nt">--cflags</span> <span class="nt">--static</span> opencv4
<span class="nt">-I</span>/usr/local/opencv4/include/opencv4/opencv <span class="nt">-I</span>/usr/local/opencv4/include/opencv4
</code></pre></div></div>

<p>使用 pkg-config 可以更加方便的编译C++代码，比如代码 <code>myapp.cpp</code> 依赖 OpenCV，那么可以使用下面方式来指定编译的flags</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="sb">`</span>pkg-config <span class="nt">--cflags</span> <span class="nt">--libs</span> opencv4<span class="sb">`</span> <span class="nt">-o</span> myapp myapp.cpp
</code></pre></div></div>]]></content><author><name></name></author><category term="c++" /><category term="linux" /><summary type="html"><![CDATA[pkg-config 入门 pkg-config 是类 Unix 操作系统上的一个库查询工具。它通过 .pc 文件来查询当前系统上已安装类库的信息。 下面是 OpenCV4 的 pc 文件， 文件中包含了OpenCV 库的很多元数据(metadata) # Package Information for pkg-config prefix=/usr/local/opencv4 exec_prefix=${prefix} libdir=${exec_prefix}/lib includedir_old=${prefix}/include/opencv4/opencv includedir_new=${prefix}/include/opencv4 Name: OpenCV Description: Open Source Computer Vision Library Version: 4.0.1 Libs: -L${exec_prefix}/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_cvv -lopencv_dnn_objdetect -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_line_descriptor -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_video -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core Libs.private: -ldl -lm -lpthread -lrt Cflags: -I${includedir_old} -I${includedir_new} pc 文件中的元数据分为两种，一种是格式如 prefix=** 的变量，一种是格式如 Name: OpenCV 关键字，变量是在 pc 文件内部使用，用来帮助定义关键字；而关键字信息会导出到 pkg-config 中。 pkg-config 中定义了一下这些关键字 Name: 当前库的名字，它不需要全局唯一，通常它和 pc 文件的文件名保持一致。 Description: 对于库的简短描述 URL: 当前库的相关信息网络地址 Version: 安装的版本号 Requires: 列出当前库所需要的依赖，依赖库的版本信息可以使用 =, &gt;, &lt;, &lt;= 和 &gt;= 来指定。 eg. Requires: OpenCV &gt;= 4.0.0 Requires.private: 列出当前库所需要的依赖，但是这些依赖并不会暴露给应用，版本格式与 Requires 相同。 Confilcts: 这是一个可选关键字，用来指明与当前库冲突的库 Cflags: 编译当前库需要的 flags 参数。如果依赖的库不支持 pkg-config， 就可以通过此关键字来指定，如果支持 pkg-config，就应该在 Requires 和 Requires.private 中指定。 Libs: 指定不支持 pkg-config 的链接依赖 flags 参数 Libs.private: 同 Requires.private 一样，当前关键字的依赖不会暴露给应用 pkg-config 默认会在 /usr/lib/pkgconfig 和 /usr/share/pkgconfig 中去加载 pc 文件，但是有些库的安装地址不在默认路径中，就需要将 pc 文件的路径添加到环境变量 PKG_CONFIG_PATH 中。 通过 pkg-config 可以查看安装库的版本 pkg-config --modversion opencv4 # 如果 pc 文件名与 Name 关键字不一致，这里需要输入的是文件名 4.0.1 --libs 可以输出编译依赖当前库的 link flags， 但是不会输出 /usr/lib 下的依赖库。 pkg-config --libs opencv4 -L/usr/local/opencv4/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_cvv -lopencv_dnn_objdetect -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_line_descriptor -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_video -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core 同时 --libs 也不会输出 OpenCV 的依赖，因为依赖 OpenCV 的代码并不直接依赖与OpenCV 的依赖。为了静态链接，可以加上选项 --static pkg-config --libs opencv4 -L/usr/local/opencv4/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_cvv -lopencv_dnn_objdetect -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_line_descriptor -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_video -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core -ldl -lm -lpthread -lrt 使用 --cflags pkg-config 会输出所有的编译flag， 加不加 --static 都一样。 pkg-config --cflags opencv4 -I/usr/local/opencv4/include/opencv4/opencv -I/usr/local/opencv4/include/opencv4 pkg-config --cflags --static opencv4 -I/usr/local/opencv4/include/opencv4/opencv -I/usr/local/opencv4/include/opencv4 使用 pkg-config 可以更加方便的编译C++代码，比如代码 myapp.cpp 依赖 OpenCV，那么可以使用下面方式来指定编译的flags g++ `pkg-config --cflags --libs opencv4` -o myapp myapp.cpp]]></summary></entry><entry><title type="html">机器学习基石 第二讲</title><link href="https://mengman.github.io/machinelearning/deeplearning/math/2020/07/12/machine-learning-foundations-lession-2.html" rel="alternate" type="text/html" title="机器学习基石 第二讲" /><published>2020-07-12T01:26:21+08:00</published><updated>2020-07-12T01:26:21+08:00</updated><id>https://mengman.github.io/machinelearning/deeplearning/math/2020/07/12/machine-learning-foundations-lession-2</id><content type="html" xml:base="https://mengman.github.io/machinelearning/deeplearning/math/2020/07/12/machine-learning-foundations-lession-2.html"><![CDATA[<h1 id="感知机">感知机</h1>

<h2 id="感知器假设集perceptron-hypothesis-set">感知器假设集（Perceptron Hypothesis Set）</h2>
<p>感知器算法:  \(h(x)=sign((\sum_{i=1}^dw_ix_i)-threshold)\)</p>

<p>对上面的公示进行变形，将<strong>threshold</strong>作为偏置，纳入 x 中，\(x_0=+1\) ;</p>

\[h(x)=sign(W^TX)\]

<p>每一个不同的W代表了算法中的一个hypothesis.</p>

<h2 id="pla-感知器学习算法">PLA 感知器学习算法</h2>

<p>要从 hypothesis set 中找到一个合适的 hypothesis g, 让 g 与目标函数 f 尽可能的相近。</p>

<p>PLA算法通过试错的方法实现模型的训练：</p>

<p>总共进行t轮的训练， t=0, 1, …</p>

<ol>
  <li>
    <p>随机初始化 \(w_0\);</p>
  </li>
  <li>
    <p>将样本 \((x_{n(t)},y_{n(t)})\) 带入PLA学习机， 如果：</p>
  </li>
</ol>

\[sign(w^T_tx_{n(t)})\neq y_{n(t)}\]

<p>那么，表示发生错误，需要对错误进行纠正。</p>

<ol>
  <li>
    <p>修正错误：</p>

\[w_{t+1} \leftarrow w_t + y_{n(t)}x_{n(t)}\]

    <p>\(w\): 代表分类线的法向量
\(x_n\): 是原点到 \(x_n\) 的向量</p>

    <p><img src="/assets/ml_base_2_1.png" alt="ml_base_2_1" /></p>
  </li>
</ol>

<ul>
  <li>当 \(y_n = +1\), 将 \(w\) 的方向向样本 \((x_n, y_n)\) 的方向转动。</li>
  <li>当 \(y_n = -1\), 将\(w\)的方向向样本 \((x_n, y_n)\) 的反方向转动。</li>
  <li>当不再出现错误的时候，训练结束。</li>
</ul>

<p><strong>PLA算法要能终止，要求训练数据集必须是线性可分的</strong></p>

<p><strong>\(w_t\) 越来越接近 \(w_f\)</strong></p>

<ul>
  <li>
    <p>\(w_f\): 目标函数 f 对应的参数，因此对于任意一个样本，它都能正确的分类：</p>

\[y_{n(t)}w^T_fx_{n(t)} \ge \min_ny_nw^T_fx_n \gt 0\]
  </li>
  <li>
    <p>衡量两个向量是否接近，可以用它们的内积，如果内积越小代表它们越不接近，相互垂直时为 0</p>

\[\begin{align}
\begin{split}
w_f^Tw_{t+1} &amp;= w_f^T(w_t+y_{n(t)}x_{n(t)}) \\
&amp;\ge w_f^Tw_t + \min_ny_nw_f^Tx_n \\
&amp;\gt w_f^Tw_t + 0
\end{split}
\end{align}\]
  </li>
</ul>

<p><strong>\(w_t\) 的增长速率不快</strong></p>

<p>\(w_t\)每次的更新不超过离分割线最远的样本的距离</p>

<ul>
  <li>\(w_t\) 的每次更新发生在有错误的时候：</li>
</ul>

\[sign(w_t^fx_{n(t)}) \neq y_{n(t)} \Leftrightarrow y_{n(t)}w_t^Tx_{n(t)} \leq 0\]

<ul>
  <li>对于每一次更新后的结果：</li>
</ul>

\[\begin{equation}\begin{split} ||w_{t+1}||^2 &amp;= ||w_t + y_{n(t)}x_{n(t)}||^2\\\\
   &amp;= ||w_t||^2 + 2y_{n(t)}w_t^Tx_{n(t)} + ||y_{n(t)}x_{n(t)}||^2\\\\
   &amp;\le ||w_t||^2 + 0 + ||y_{n(t)x_{n(t)}}||^2\\\\
   &amp;\le ||w_t||^2 + \max_n||y_{n(t)}x_{n(t)}||^2\end{split}\end{equation}\]

<p>其中  \(\max_n \Vert y_{n(t)}x_{n(t)} \Vert ^2\)  就代表了距离到分隔线最远的点的距离。</p>

\[\begin{equation}\begin{split}
   \text{start from w_0 = 0, after T mistake corrections,} \\
   
   \frac{w_f^T}{\Vert w_f \Vert} \frac{w_T}{\Vert w_T \Vert} \ge \sqrt T * \text{constant}
   
   \end{split}\end{equation}\]

<p>\(w_f^Tw_{t+1}\) 的内积是小于等于1的，再根据上面的式子，知道T不可能为无穷大，所以运算会终止。</p>

<h2 id="pocket-算法">Pocket 算法</h2>
<p><strong>算法步骤</strong></p>

<ol>
  <li>随机初始化 w</li>
  <li>进行 t 轮的学习， t = 0, 1, …</li>
  <li>如果发生错误，按照 PLA 算法对 w进行纠正：\(w_{t+1} \leftarrow w_t + y_{n(t)}x_{n(t)}\)</li>
  <li>判断对比纠正后的算法与之前算法的错误率，如果更好，者保留新的w<sub>t+1</sub>, 否者保留之前的w。</li>
  <li>运算足够多次之后停止运算。</li>
</ol>

<p>Pocket算法是PLA的改进算法，用于解决<strong>线性不可分</strong>的数据集。
Pocket算法的运算量大：对于比PLA，在得到新的w<sub>t+1</sub>， 需要将所有数据集运算一遍，来获得错误率。</p>]]></content><author><name></name></author><category term="machinelearning" /><category term="deeplearning" /><category term="math" /><summary type="html"><![CDATA[感知机 感知器假设集（Perceptron Hypothesis Set） 感知器算法: \(h(x)=sign((\sum_{i=1}^dw_ix_i)-threshold)\) 对上面的公示进行变形，将threshold作为偏置，纳入 x 中，\(x_0=+1\) ; \[h(x)=sign(W^TX)\] 每一个不同的W代表了算法中的一个hypothesis. PLA 感知器学习算法 要从 hypothesis set 中找到一个合适的 hypothesis g, 让 g 与目标函数 f 尽可能的相近。 PLA算法通过试错的方法实现模型的训练： 总共进行t轮的训练， t=0, 1, … 随机初始化 \(w_0\); 将样本 \((x_{n(t)},y_{n(t)})\) 带入PLA学习机， 如果： \[sign(w^T_tx_{n(t)})\neq y_{n(t)}\] 那么，表示发生错误，需要对错误进行纠正。 修正错误： \[w_{t+1} \leftarrow w_t + y_{n(t)}x_{n(t)}\] \(w\): 代表分类线的法向量 \(x_n\): 是原点到 \(x_n\) 的向量 当 \(y_n = +1\), 将 \(w\) 的方向向样本 \((x_n, y_n)\) 的方向转动。 当 \(y_n = -1\), 将\(w\)的方向向样本 \((x_n, y_n)\) 的反方向转动。 当不再出现错误的时候，训练结束。 PLA算法要能终止，要求训练数据集必须是线性可分的 \(w_t\) 越来越接近 \(w_f\) \(w_f\): 目标函数 f 对应的参数，因此对于任意一个样本，它都能正确的分类： \[y_{n(t)}w^T_fx_{n(t)} \ge \min_ny_nw^T_fx_n \gt 0\] 衡量两个向量是否接近，可以用它们的内积，如果内积越小代表它们越不接近，相互垂直时为 0 \[\begin{align} \begin{split} w_f^Tw_{t+1} &amp;= w_f^T(w_t+y_{n(t)}x_{n(t)}) \\ &amp;\ge w_f^Tw_t + \min_ny_nw_f^Tx_n \\ &amp;\gt w_f^Tw_t + 0 \end{split} \end{align}\] \(w_t\) 的增长速率不快 \(w_t\)每次的更新不超过离分割线最远的样本的距离 \(w_t\) 的每次更新发生在有错误的时候： \[sign(w_t^fx_{n(t)}) \neq y_{n(t)} \Leftrightarrow y_{n(t)}w_t^Tx_{n(t)} \leq 0\] 对于每一次更新后的结果： \[\begin{equation}\begin{split} ||w_{t+1}||^2 &amp;= ||w_t + y_{n(t)}x_{n(t)}||^2\\\\ &amp;= ||w_t||^2 + 2y_{n(t)}w_t^Tx_{n(t)} + ||y_{n(t)}x_{n(t)}||^2\\\\ &amp;\le ||w_t||^2 + 0 + ||y_{n(t)x_{n(t)}}||^2\\\\ &amp;\le ||w_t||^2 + \max_n||y_{n(t)}x_{n(t)}||^2\end{split}\end{equation}\] 其中 \(\max_n \Vert y_{n(t)}x_{n(t)} \Vert ^2\) 就代表了距离到分隔线最远的点的距离。 \[\begin{equation}\begin{split} \text{start from w_0 = 0, after T mistake corrections,} \\ \frac{w_f^T}{\Vert w_f \Vert} \frac{w_T}{\Vert w_T \Vert} \ge \sqrt T * \text{constant} \end{split}\end{equation}\] \(w_f^Tw_{t+1}\) 的内积是小于等于1的，再根据上面的式子，知道T不可能为无穷大，所以运算会终止。 Pocket 算法 算法步骤 随机初始化 w 进行 t 轮的学习， t = 0, 1, … 如果发生错误，按照 PLA 算法对 w进行纠正：\(w_{t+1} \leftarrow w_t + y_{n(t)}x_{n(t)}\) 判断对比纠正后的算法与之前算法的错误率，如果更好，者保留新的wt+1, 否者保留之前的w。 运算足够多次之后停止运算。 Pocket算法是PLA的改进算法，用于解决线性不可分的数据集。 Pocket算法的运算量大：对于比PLA，在得到新的wt+1， 需要将所有数据集运算一遍，来获得错误率。]]></summary></entry><entry><title type="html">软件设计模型-功能开关</title><link href="https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Feature-Toggles.html" rel="alternate" type="text/html" title="软件设计模型-功能开关" /><published>2020-04-20T17:26:21+08:00</published><updated>2020-04-20T17:26:21+08:00</updated><id>https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Feature-Toggles</id><content type="html" xml:base="https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Feature-Toggles.html"><![CDATA[<h2 id="功能开关">功能开关</h2>
<p>本文受到 Pete Hodgson 的文章 <a href="https://www.martinfowler.com/articles/feature-toggles.html">Feature Toggles (aka Feature Flags)</a> 启发，原文内容比本文更加丰富。</p>

<h3 id="简单的功能开关">简单的功能开关</h3>

<p>场景一：你刚刚开发完一个新的功能，然后需求告诉你，由于这个功能使用场景的限制，需要添加一个开关，能够让这个功能在某些环境打开或者关闭。</p>

<p>场景二：你实现了一个新版本的算法，但是并不希望立刻在线上启用，希望能进行更多的测试，所以需要添加一个开关，在测试环境打开，在生产环境保持关闭。</p>

<p>这个时候你只需要实现一个简单的功能开关即可。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">doSomeThing</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">useNewAlgorithm</span> <span class="o">:=</span> <span class="no">false</span>
    <span class="c">// useNewAlgorithm := true // uncomment if you working with new algorithm</span>
    <span class="k">if</span> <span class="n">useNewAlgoritem</span> <span class="p">{</span>
        <span class="n">doSomeThingNew</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">doSomeThingOld</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doSomeThingNew</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// implement something new</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doSomeThingOld</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// implement something old</span>
<span class="p">}</span>

</code></pre></div></div>

<p>我们把新的功能写到 <code>doSomeThingNew</code> 函数中，并通过 <code>useNewAlgorithm</code> 变量来控制是否调用新功能。这个方法虽然简单，但是我们无法在运行时动态的去决定是否启用新的功能。为了实现对于新功能的动态控制，我们可以引入一个<strong>开关路由器</strong>（toggle router）来实现。</p>

<h3 id="开关路由器">开关路由器</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ToggleRouter</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">featureConfig</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tr</span> <span class="o">*</span><span class="n">ToggleRouter</span><span class="p">)</span> <span class="n">SetFeature</span><span class="p">(</span><span class="n">featureName</span> <span class="kt">string</span><span class="p">,</span> <span class="n">isEnabled</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">isEnabled</span> <span class="p">{</span>
		<span class="n">tr</span><span class="o">.</span><span class="n">featureConfig</span><span class="p">[</span><span class="n">featureName</span><span class="p">]</span> <span class="o">=</span> <span class="k">struct</span><span class="p">{}{}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nb">delete</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">featureConfig</span><span class="p">,</span> <span class="n">featureName</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tr</span> <span class="o">*</span><span class="n">ToggleRouter</span><span class="p">)</span> <span class="n">IsFeatureEnabled</span><span class="p">(</span><span class="n">featureName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">tr</span><span class="o">.</span><span class="n">featureConfig</span><span class="p">[</span><span class="n">featureName</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">ok</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewToggleRouter</span><span class="p">(</span><span class="n">features</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">tr</span> <span class="o">*</span><span class="n">ToggleRouter</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">tr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ToggleRouter</span><span class="p">{</span>
		<span class="n">featureConfig</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">struct</span><span class="p">{}),</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">feat</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">features</span> <span class="p">{</span>
		<span class="n">tr</span><span class="o">.</span><span class="n">SetFeature</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="no">true</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">toggleRouter</span> <span class="o">=</span> <span class="n">NewToggleRouter</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"newAlgo"</span><span class="p">})</span>

<span class="k">func</span> <span class="n">doSomeThing</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">toggleRouter</span><span class="o">.</span><span class="n">IsFeatureEnabled</span><span class="p">(</span><span class="s">"newAlgo"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">doSomeThingNew</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">doSomeThingOld</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过开关路由器我们可以动态的设置功能的启用与否。ToggleRouter 可以通过配置文件创建，或者通过配置界面，或者 API 接口来进行配置。到现在问题似乎已经解决了，然而随着越来越多的新功能加入，越来越多的功能需要通过开关来配置是否开启，代码中出现了越来越多的<strong>开关点</strong>，代码也变得越来越难以理解和维护。</p>

<p>让我们看一个新例子，<code>InvoiceEmailler</code> 会根据收据发送一封电子邮件，现在我们希望能加上一个新的功能，在邮件中添加退货链接。而这个退货链接只是在特定的情况下才会触发。下面代码中是根据 开关中是否包含 <code>next-gen-ecomm</code> 来判断的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">toggle</span> <span class="o">=</span> <span class="n">GetFeatureToggleRouter</span><span class="p">()</span>

<span class="k">type</span> <span class="n">InvoiceEmailler</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">invoice</span> <span class="n">Invoice</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">emailler</span> <span class="o">*</span><span class="n">InvoiceEmailler</span><span class="p">)</span> <span class="n">GenerateInvoiceEmail</span><span class="p">()</span> <span class="n">Email</span> <span class="p">{</span>
    <span class="n">baseEmail</span> <span class="o">:=</span> <span class="n">buildEmailForInvoice</span><span class="p">(</span><span class="n">emailler</span><span class="o">.</span><span class="n">invoice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">toggle</span><span class="o">.</span><span class="n">IsFeatureEnabled</span><span class="p">(</span><span class="s">"next-gen-ecomm"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addOrderCallationContentToEmail</span><span class="p">(</span><span class="n">baseEmail</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">baseEmail</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是，对于一个功能是否启用的判断逻辑可能是十分复杂的，也许在 A 情况下需要开启，在 B 情况下需要关闭；或者需要对某一部分用户开启这一项功能，对另一部分用户关闭这一功能；开关的判断逻辑可能会频繁的迭代。如果要更新判断逻辑，我们不得不在每个开关点去修改判断逻辑。这是代码中的第一个问题：<strong>开关点与开关的判断逻辑耦合在一起</strong>。</p>

<h3 id="解耦开关点与开关路由器">解耦开关点与开关路由器</h3>

<p>幸好<a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">“软件中的任何问题都可以通过引入一个间接层来解决”</a>, 通过增加一个<strong>开关逻辑判断层</strong>我们可以解耦开关点与开关判断逻辑。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">FeatureDecisions</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">toggle</span> <span class="o">*</span><span class="n">ToggleRouter</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">descisions</span> <span class="o">*</span><span class="n">FeatureDecisions</span><span class="p">)</span> <span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">descisions</span><span class="o">.</span><span class="n">toggle</span><span class="o">.</span><span class="n">IsFeatureEnabled</span><span class="p">(</span><span class="s">"new-gen-ecomm"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewFeatureDecisions</span><span class="p">(</span><span class="n">toggle</span> <span class="o">*</span><span class="n">ToggleRouter</span><span class="p">)</span> <span class="n">FeatureDecisions</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FeatureDecisions</span><span class="p">{</span><span class="n">toggle</span><span class="o">:</span> <span class="n">toggle</span><span class="p">}</span>
<span class="p">}</span>


<span class="k">var</span> <span class="n">toggle</span> <span class="o">=</span> <span class="n">GetFeatureToggleRouter</span><span class="p">()</span>
<span class="k">var</span> <span class="n">featureDecisions</span> <span class="o">=</span> <span class="n">NewFeatureDecision</span><span class="p">(</span><span class="n">toggle</span><span class="p">)</span>

<span class="k">type</span> <span class="n">InvoiceEmailler</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">invoice</span> <span class="n">Invoice</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">emailler</span> <span class="o">*</span><span class="n">InvoiceEmailler</span><span class="p">)</span> <span class="n">GenerateInvoiceEmail</span><span class="p">()</span> <span class="n">Email</span> <span class="p">{</span>
    <span class="n">baseEmail</span> <span class="o">:=</span> <span class="n">buildEmailForInvoice</span><span class="p">(</span><span class="n">emailler</span><span class="o">.</span><span class="n">invoice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">featureDecisions</span><span class="o">.</span><span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addOrderCallationContentToEmail</span><span class="p">(</span><span class="n">baseEmail</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">baseEmail</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>通过引入 <code>FeatureDecisions</code> 之后，<code>InvoiceEmailler</code> 不再关心添加退货链接的逻辑是什么；而后续对与添加退货链接逻辑的更新也与 <code>InvoiceEmailler</code> 无关。从而实现了<strong>开关点与开关判断逻辑的解耦</strong>。</p>

<h3 id="判断翻转inversion-of-decision">判断翻转(Inversion of Decision)</h3>

<p>虽然在上一步中，我们通过添加<strong>判断逻辑层</strong>实现了判断逻辑与开关点的解耦，但是 <code>InvoiceEmailler</code> 依旧与 <code>FeatureDecisions</code> 耦合在一起，在执行 <code>GenerateInvoiceEmail()</code> 需要先创建或者获取 <code>FeatureDecisions</code> ，这处代码“坏味道”带来了两个问题：</p>

<ol>
  <li>它不方便对代码进行测试，在测试 <code>GenerateInvoiceEmail()</code> 函数之前，我们必须先设置好调用 <code>GetFeatureToggleRouter()</code> 与 <code>NewFeatureDecision()</code> 函数的环境，才能确保可以到达待测试逻辑代码块。</li>
  <li>随着项目功能模块的增多，每个模块都与 <code>FeatureDecisions</code> 模块发生了耦合，使得该模块变成了全局依赖模块。</li>
</ol>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// invoice_emailler.go</span>

<span class="k">type</span> <span class="n">EmaillerDecisions</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">InvoiceEmailler</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">invoice</span> <span class="n">Invoice</span>
    <span class="n">decisions</span> <span class="n">EmaillerDecisions</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">emailler</span> <span class="o">*</span><span class="n">InvoiceEmailler</span><span class="p">)</span> <span class="n">SetDecisions</span><span class="p">(</span><span class="n">decisions</span> <span class="o">*</span><span class="n">FeatureDecisions</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">emailler</span><span class="o">.</span><span class="n">decisions</span> <span class="o">=</span> <span class="n">decisions</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">emailler</span> <span class="o">*</span><span class="n">InvoiceEmailler</span><span class="p">)</span> <span class="n">GenerateInvoiceEmail</span><span class="p">()</span> <span class="n">Email</span> <span class="p">{</span>
    <span class="n">baseEmail</span> <span class="o">:=</span> <span class="n">buildEmailForInvoice</span><span class="p">(</span><span class="n">emailler</span><span class="o">.</span><span class="n">invoice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">emailler</span><span class="o">.</span><span class="n">decisions</span><span class="o">.</span><span class="n">includeOrderCancellationInEmail</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addOrderCallationContentToEmail</span><span class="p">(</span><span class="n">baseEmail</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">baseEmail</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// inject decisions module</span>
<span class="k">func</span> <span class="n">NewInvoiceEmailler</span><span class="p">(</span><span class="n">decisions</span> <span class="n">EmaillerDecisions</span><span class="err">，</span> <span class="n">invoice</span> <span class="n">Invoice</span><span class="p">)</span> <span class="o">*</span><span class="n">InvoiceEmailler</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">InvoiceEmailler</span><span class="p">{</span>
        <span class="n">invoice</span><span class="o">:</span> <span class="n">invoice</span><span class="p">,</span>
        <span class="n">decisions</span><span class="o">:</span> <span class="n">decisions</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>此处“坏味道”的根本原因是业务模块对 <code>FeatureDecisions</code> 模块的依赖，通过<strong>控制反转</strong>在 <code>InvoiceEmailler</code> 模块创建时，将 <code>FeatureDecisions</code> 注入到 <code>InvoiceEmailler</code> 中，就可以消除业务模块对与 <code>FeatureDecisions</code> 模块的依赖。</p>

<h3 id="消除条件判断">消除条件判断</h3>

<p>到现在位置我们代码已经获得了很大优化，那我们能不能在进一步消除 <code>GenerateInvoiceEmail()</code> 函数的条件判断呢？ 对于简单的场景下的条件判断语句是没有什么问题的，但是在复杂的业务逻辑中，太多的条件判断并不利于代码的维护。比如如果配置中包含 feature “after-sales-service”,  需要在 email 中添加售后服务的信息。现在我们必须回到  <code>GenerateInvoiceEmail()</code>，修改判断条件再加上添加售后服务的信息。</p>

<p>通过策略模式，我们可以进一步的消除业务代码中的逻辑判断，提升代码的可扩展性。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="n">EmaillerDecisions</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="kt">bool</span>

	<span class="n">IncludeAfterSalesServiceInEmail</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">AdditionalContentEnhancer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">EnhanceContent</span><span class="p">(</span><span class="n">Email</span><span class="p">)</span> <span class="n">Email</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">InvoiceEmailler</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">invoice</span>  <span class="n">Invoice</span>
	<span class="n">enhancer</span> <span class="n">AdditionalContentEnhancer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">emailler</span> <span class="o">*</span><span class="n">InvoiceEmailler</span><span class="p">)</span> <span class="n">GenerateInvoiceEmail</span><span class="p">()</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="n">baseEmail</span> <span class="o">:=</span> <span class="n">buildEmailForInvoice</span><span class="p">(</span><span class="n">emailler</span><span class="o">.</span><span class="n">invoice</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">enhancer</span><span class="o">.</span><span class="n">EnhanceContent</span><span class="p">(</span><span class="n">baseEmail</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">OrderCallationContentEnhancer</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">OrderCallationContentEnhancer</span><span class="p">)</span> <span class="n">addOrderCallationContentToEmail</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="p">(</span><span class="n">newEmail</span> <span class="n">Email</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// implement addOrderCallationContentToEmail</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">OrderCallationContentEnhancer</span><span class="p">)</span> <span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">addOrderCallationContentToEmail</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">AfterSalesServiceContentEnhancer</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">AfterSalesServiceContentEnhancer</span><span class="p">)</span> <span class="n">addAfterSalesServiceContentToEmail</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="p">(</span><span class="n">newEmail</span> <span class="n">Email</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// implement addAfterSalesServiceContentToEmail</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">AfterSalesServiceContentEnhancer</span><span class="p">)</span> <span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">addAfterSalesServiceContentToEmail</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">OrderCallationAndAfterSalesServiceContentEnhancer</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">OrderCallationContentEnhancer</span>
	<span class="n">AfterSalesServiceContentEnhancer</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">OrderCallationAndAfterSalesServiceContentEnhancer</span><span class="p">)</span> <span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="n">email</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">OrderCallationContentEnhancer</span><span class="o">.</span><span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
	<span class="n">email</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">AfterSalesServiceContentEnhancer</span><span class="o">.</span><span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">email</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">IdentityContentEnhancer</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">IdentityContentEnhancer</span><span class="p">)</span> <span class="n">EnhanceContent</span><span class="p">(</span><span class="n">email</span> <span class="n">Email</span><span class="p">)</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">email</span>
<span class="p">}</span>

<span class="c">// inject decisions module</span>
<span class="k">func</span> <span class="n">NewInvoiceEmailler</span><span class="p">(</span><span class="n">decisions</span> <span class="n">EmaillerDecisions</span><span class="p">,</span> <span class="n">invoice</span> <span class="n">Invoice</span><span class="p">)</span> <span class="o">*</span><span class="n">InvoiceEmailler</span> <span class="p">{</span>
	<span class="n">emailler</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">InvoiceEmailler</span><span class="p">{</span>
		<span class="n">invoice</span><span class="o">:</span> <span class="n">invoice</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">decisions</span><span class="o">.</span><span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">decisions</span><span class="o">.</span><span class="n">IncludeAfterSalesServiceInEmail</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">emailler</span><span class="o">.</span><span class="n">enhancer</span> <span class="o">=</span> <span class="n">OrderCallationAndAfterSalesServiceContentEnhancer</span><span class="p">{}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">decisions</span><span class="o">.</span><span class="n">IncludeOrderCancellationInEmail</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">emailler</span><span class="o">.</span><span class="n">enhancer</span> <span class="o">=</span> <span class="n">OrderCallationContentEnhancer</span><span class="p">{}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">decisions</span><span class="o">.</span><span class="n">IncludeAfterSalesServiceInEmail</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">emailler</span><span class="o">.</span><span class="n">enhancer</span> <span class="o">=</span> <span class="n">AfterSalesServiceContentEnhancer</span><span class="p">{}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">emailler</span><span class="o">.</span><span class="n">enhancer</span> <span class="o">=</span> <span class="n">IdentityContentEnhancer</span><span class="p">{}</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div></div>

<p>到现在我们就差不多完成了对于代码的优化。</p>]]></content><author><name></name></author><category term="designpattern" /><category term="softwareengineering" /><summary type="html"><![CDATA[功能开关 本文受到 Pete Hodgson 的文章 Feature Toggles (aka Feature Flags) 启发，原文内容比本文更加丰富。]]></summary></entry><entry><title type="html">Python 依赖管理软件 Poetry 上手</title><link href="https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Python-Poetry-In-Action.html" rel="alternate" type="text/html" title="Python 依赖管理软件 Poetry 上手" /><published>2020-04-20T17:26:21+08:00</published><updated>2020-04-20T17:26:21+08:00</updated><id>https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Python-Poetry-In-Action</id><content type="html" xml:base="https://mengman.github.io/designpattern/softwareengineering/2020/04/20/Python-Poetry-In-Action.html"><![CDATA[<h2 id="python-项目管理-poetry-上手">Python 项目管理 Poetry 上手</h2>

<p>Python 项目依赖管理工具有 virtualenv pipenv anaconda，来帮助项目做到项目之间的环境隔离，依赖管理等。今天介绍的 Poetry 是它更像是 Python 项目 CLI 工具，能够进行项目模板创建，依赖管理，项目构建与发布等。Poetry v0.1.0 版本发布2018-02，到现在两年的时间，目前社区比较活跃。</p>

<h3 id="poetry-配置">Poetry 配置</h3>

<h4 id="1--安装">1  安装</h4>

<p>OSX / Linux / bashonwindows 使用脚本自动安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-sSL</span> https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python
</code></pre></div></div>

<p>在类 *nix 的系统中 Poetry 会默认安装在 <code>$HOME/.poetry/bin </code> 中， 在window系统下默认安装目录为 <code>%USERPROFILE%\.poetry\bin</code>。</p>

<p>如果要修改安装目录，需要在运行安装脚本时通过环境变量 <code>POETRY_HOME</code> 来指定。 使用参数 <code>--version</code> 或者环境变量 <code>POETRY_VERSION</code> 可以指定安装版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">POETRY_HOME</span><span class="o">=</span>/etc/poetry python get-poetry.py <span class="nt">--version</span> 1.0.5
</code></pre></div></div>

<h4 id="2-安装检查">2. 安装检查</h4>

<p>安装成功后检查 poetry 版本</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>poetry <span class="nt">--version</span>
</code></pre></div></div>

<p>如果无法找到  <code>poetry</code> 命令， 那么记得把安装目录加到 $PATH 中。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export</span> <span class="nv">$PATH</span><span class="o">=</span><span class="nv">$HOME</span>/.poetry/bin:<span class="nv">$PATH</span>
</code></pre></div></div>

<h4 id="3更新卸载-poetry">3.更新&amp;卸载 Poetry</h4>

<p>更新 Poetry</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 更新到最新的稳定版本</span>
poetry self update

<span class="c"># 更新到预览版本</span>
poetry self udpate <span class="nt">--preview</span>

<span class="c"># 更新到指定版本</span>
poetry self update 1.0.5
</code></pre></div></div>

<p>卸载 Poetry</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python get-poetry.py <span class="nt">--uninstall</span>
</code></pre></div></div>

<h3 id="基本用法">基本用法</h3>]]></content><author><name></name></author><category term="designpattern" /><category term="softwareengineering" /><summary type="html"><![CDATA[Python 项目管理 Poetry 上手]]></summary></entry></feed>